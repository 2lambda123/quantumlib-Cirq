syntax = "proto3";

import "cirq/google/api/v2/metrics.proto";
import "cirq/google/api/v2/program.proto";

package cirq.google.api.v2;

option java_package = "com.google.cirq.google.api.v2";
option java_outer_classname = "BatchProto";
option java_multiple_files = true;

//  This message represents a request to execute a custom calibration routine.
//
message FocusedCalibration {
     // This field represents each invocation of a calibration
     // procedure.
     //
     // For instance, each (unique) moment of a circuit could be
     // calibrated using parallel_xeb.  In this case,
     // each moment would have its own CalibrationLayer.
     //
     // Some calibrations, such as readout calibration,
     // will only have one layer.
     repeated CalibrationLayer layers = 1;
}

// Each CalibrationLayer represents one invocation
// of a calibration procedure.
message CalibrationLayer {
     // The type of the calibration procedure to execute.
     // There will be a number of calibration types that can be run,
     // so this will need to be in a set of acceptable values.
     string calibration_type = 1;

     // A circuit that identifies the layer or circuit to optimize
     // if the calibration requires this.  For many calibrations,
     // this will be a single moment representing the layer to
     // optimize for.
     Circuit circuit = 2;
}

// The results returned by a FocusedCalibration request.
message FocusedCalibrationResults {

     // The results of each CalibrationLayer request.
     // There will be one CalibrationLayerResults message for each
     // CalibrationLayer in the request, and the results will
     // correspond to the order of the requests.
     repeated CalibrationLayerResults results = 1;
}

// Response codes for Calibration requests
enum CalibrationLayerCode {

     // For backwards compatibility.
     UNKNOWN = 0;

     // Successful run of the calibration.
     SUCCESS = 1;

     // Miscellaenous errors not covered by the below conditions.
     ERROR_OTHER = 2;

     // The parameters given to the calibration were not valid.
     // For instance, multiple moments were given to a type of calibration
     // that expects a single moment.
     ERROR_INVALID_PARAMETERS = 3;

     // The calibration took too long and was aborted.
     ERROR_TIMEOUT = 4;

     // The calibration failed for internal reasons.  For instance,
     // suitable device parameters could not be acheived or dependencies
     // needed by the calibration did not exist.
     ERROR_CALIBRATION_FAILED = 5;
}


message CalibrationLayerResults {
     // Whether the calibration procedure was a success or failure.
     CalibrationLayerCode code = 1;

     // On non-successful results, contains additional information
     // about the details of the error.
     string error_message = 2;

     // A token identifying the calibration result.
     // This could be used to tag focused circuits that use parameters
     // derived from this calibration.
     string token = 3;

     // Results, such as gate fidelities, gate angles, etc
     // would be returned in a similar format to calibration metrics.
     // This allows the return result to be easily extensible.
     MetricsSnapshot metrics = 4;

     // Timestamp of when the calibration is valid until, specified as
     // milliseconds since the Unix epoch time.
     uint64 valid_until_ms = 5;
}
