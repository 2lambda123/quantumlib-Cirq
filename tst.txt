============================= test session starts ==============================
platform linux -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0
rootdir: /home/vtomole/Cirq, inifile:
plugins: cov-2.5.1
collected 5140 items

cirq/decompositions_test.py ............................................ [  0%]
........................................................................ [  2%]
.......................                                                  [  2%]
cirq/circuits/circuit_dag_test.py ..............                         [  2%]
cirq/circuits/circuit_test.py .......................................... [  3%]
.........FF.........................................                     [  4%]
cirq/circuits/convert_to_cz_and_single_gates_test.py ........            [  4%]
cirq/circuits/drop_empty_moments_test.py .                               [  4%]
cirq/circuits/drop_negligible_test.py ....                               [  5%]
cirq/circuits/expand_composite_test.py ............                      [  5%]
cirq/circuits/insert_strategy_test.py .                                  [  5%]
cirq/circuits/merge_interactions_test.py .F.........                     [  5%]
cirq/circuits/merge_single_qubit_gates_test.py ......                    [  5%]
cirq/circuits/moment_test.py .......                                     [  5%]
cirq/circuits/optimization_pass_test.py ....                             [  5%]
cirq/circuits/qasm_output_test.py ..............                         [  6%]
cirq/circuits/text_diagram_drawer_test.py ......                         [  6%]
cirq/contrib/acquaintance/devices_test.py ..                             [  6%]
cirq/contrib/acquaintance/executor_test.py ............................. [  6%]
.......                                                                  [  6%]
cirq/contrib/acquaintance/gates_test.py ................................ [  7%]
.......................................................                  [  8%]
cirq/contrib/acquaintance/permutation_test.py .....                      [  8%]
cirq/contrib/acquaintance/shift_test.py .......                          [  8%]
cirq/contrib/acquaintance/strategy_test.py ...                           [  8%]
cirq/contrib/jobs/depolarizer_channel_test.py .FFFF                      [  9%]
cirq/contrib/jobs/job_test.py .                                          [  9%]
cirq/contrib/paulistring/clifford_optimize_test.py .....                 [  9%]
cirq/contrib/paulistring/convert_gate_set_test.py ...................    [  9%]
cirq/contrib/paulistring/convert_to_clifford_gates_test.py .......       [  9%]
cirq/contrib/paulistring/convert_to_pauli_string_phasors_test.py .....   [  9%]
cirq/contrib/paulistring/optimize_test.py ...                            [  9%]
cirq/contrib/paulistring/pauli_string_dag_test.py ......                 [  9%]
cirq/contrib/paulistring/pauli_string_optimize_test.py ...               [ 10%]
cirq/contrib/paulistring/pauli_string_phasor_test.py ....F....F.F....... [ 10%]
........................................................................ [ 11%]
........................................................................ [ 13%]
........................................................................ [ 14%]
........................................................................ [ 15%]
........................................................................ [ 17%]
........................................................................ [ 18%]
........................................................................ [ 20%]
........................................................................ [ 21%]
..........................................................F...           [ 22%]
cirq/contrib/paulistring/pauli_string_raw_types_test.py ...              [ 22%]
cirq/contrib/paulistring/recombine_test.py .                             [ 22%]
cirq/contrib/paulistring/separate_test.py .                              [ 22%]
cirq/contrib/qcircuit/qcircuit_test.py ....                              [ 22%]
cirq/contrib/quirk/export_to_quirk_test.py ...F...                       [ 23%]
cirq/devices/grid_qubit_test.py .......                                  [ 23%]
cirq/experiments/google_v2_supremacy_circuit_test.py .                   [ 23%]
cirq/extension/cast_test.py .                                            [ 23%]
cirq/extension/extensions_test.py .............                          [ 23%]
cirq/google/convert_to_xmon_gates_test.py .                              [ 23%]
cirq/google/decompositions_test.py ..................................... [ 24%]
............                                                             [ 24%]
cirq/google/eject_full_w_test.py .....F                                  [ 24%]
cirq/google/eject_z_test.py ........F..                                  [ 24%]
cirq/google/merge_rotations_test.py .....                                [ 24%]
cirq/google/optimize_test.py ..........                                  [ 25%]
cirq/google/params_test.py .......................                       [ 25%]
cirq/google/programs_test.py .....                                       [ 25%]
cirq/google/xmon_device_test.py ..................                       [ 26%]
cirq/google/xmon_gates_test.py ........FF..F...............FF...F..      [ 26%]
cirq/google/engine/engine_test.py ..................                     [ 27%]
cirq/google/engine/env_config_test.py .                                  [ 27%]
cirq/google/sim/mem_manager_test.py .......                              [ 27%]
cirq/google/sim/xmon_simulator_test.py ................................. [ 27%]
....................F.............................................       [ 29%]
cirq/google/sim/xmon_stepper_test.py ................................... [ 29%]
...................................................................      [ 31%]
cirq/linalg/combinators_test.py .......                                  [ 31%]
cirq/linalg/decompositions_test.py ..................................... [ 32%]
.......................................................                  [ 33%]
cirq/linalg/diagonalize_test.py ........................................ [ 33%]
........................................................................ [ 35%]
........................................................................ [ 36%]
........................................................................ [ 38%]
...........................................................              [ 39%]
cirq/linalg/predicates_test.py ................                          [ 39%]
cirq/linalg/tolerance_test.py .....                                      [ 39%]
cirq/linalg/transformations_test.py .........                            [ 39%]
cirq/line/line_qubit_test.py ........                                    [ 39%]
cirq/line/placement/anneal_test.py ................                      [ 40%]
cirq/line/placement/chip_test.py ........                                [ 40%]
cirq/line/placement/greedy_test.py ..........................            [ 40%]
cirq/line/placement/line_test.py ..                                      [ 40%]
cirq/line/placement/optimization_test.py ......                          [ 41%]
cirq/line/placement/sequence_test.py ...                                 [ 41%]
cirq/ops/clifford_gate_test.py ......................................... [ 41%]
........................................................................ [ 43%]
........................................................................ [ 44%]
........................................................................ [ 46%]
........................................................................ [ 47%]
........................................................................ [ 48%]
........................................................................ [ 50%]
........................................................................ [ 51%]
........................................................................ [ 53%]
........................................................................ [ 54%]
........................................................................ [ 55%]
........................................................................ [ 57%]
........................................................................ [ 58%]
........................................................................ [ 60%]
........................................................................ [ 61%]
........................................................................ [ 62%]
........................................................................ [ 64%]
........................................................................ [ 65%]
........................................................................ [ 67%]
........................................................................ [ 68%]
........................................................................ [ 69%]
........................................................................ [ 71%]
........................................................................ [ 72%]
........................................................................ [ 74%]
........................................................................ [ 75%]
................................................                         [ 76%]
cirq/ops/common_gates_test.py ....F...FFFF.F..FF.....FF........F..       [ 77%]
cirq/ops/controlled_gate_test.py ...FFFFFFFF......F......                [ 77%]
cirq/ops/eigen_gate_test.py F....FFF.FF                                  [ 77%]
cirq/ops/gate_features_test.py ......................                    [ 78%]
cirq/ops/gate_operation_test.py ........F..                              [ 78%]
cirq/ops/matrix_gates_test.py ...............                            [ 78%]
cirq/ops/op_tree_test.py .....                                           [ 78%]
cirq/ops/pauli_interaction_gate_test.py ................................ [ 79%]
........................................................................ [ 80%]
........................................................................ [ 82%]
........................................................................ [ 83%]
..........................................F..........                    [ 84%]
cirq/ops/pauli_string_test.py .......................................... [ 85%]
........................................................................ [ 86%]
........................................................................ [ 88%]
........................................................................ [ 89%]
........................................................................ [ 91%]
........................................................................ [ 92%]
........................................................................ [ 93%]
........................................................................ [ 95%]
.......................                                                  [ 95%]
cirq/ops/pauli_test.py .............                                     [ 96%]
cirq/ops/qubit_order_test.py ........                                    [ 96%]
cirq/ops/raw_types_test.py ...                                           [ 96%]
cirq/ops/reversible_composite_gate_test.py ....                          [ 96%]
cirq/ops/three_qubit_gates_test.py .F..................                  [ 96%]
cirq/protocols/apply_unitary_to_tensor_test.py .                         [ 96%]
cirq/protocols/circuit_diagram_info_test.py .....                        [ 96%]
cirq/protocols/inverse_test.py ..................                        [ 97%]
cirq/protocols/unitary_test.py .                                         [ 97%]
cirq/schedules/schedule_test.py ........                                 [ 97%]
cirq/schedules/scheduled_operation_test.py ..                            [ 97%]
cirq/schedules/schedulers_test.py ..........                             [ 97%]
cirq/study/resolver_test.py ...                                          [ 97%]
cirq/study/sweeps_test.py .........                                      [ 97%]
cirq/study/trial_result_test.py ....                                     [ 97%]
cirq/study/visualize_test.py .                                           [ 97%]
cirq/testing/circuit_compare_test.py ..............                      [ 98%]
cirq/testing/equals_tester_test.py ..............                        [ 98%]
cirq/testing/file_tester_test.py ..                                      [ 98%]
cirq/testing/lin_alg_utils_test.py ..                                    [ 98%]
cirq/testing/random_circuit_test.py ...........                          [ 98%]
cirq/testing/sample_circuits_test.py .                                   [ 98%]
cirq/value/angle_test.py ...                                             [ 98%]
cirq/value/duration_test.py .........                                    [ 99%]
cirq/value/timestamp_test.py ......                                      [ 99%]
dev_tools/bash_scripts_test.py ...                                       [ 99%]
dev_tools/incremental_coverage_test.py .                                 [ 99%]
dev_tools/shell_tools_test.py ......                                     [ 99%]
dev_tools/profiling/benchmark_simulators_test.py .....                   [ 99%]
docs/snippets_test.py ...........F........                               [ 99%]
examples/examples_test.py ........                                       [100%]

=================================== FAILURES ===================================
____________________________ test_is_parameterized _____________________________

    def test_is_parameterized():
        a, b = cirq.LineQubit.range(2)
        circuit = cirq.Circuit.from_ops(
            cirq.CZ(a, b)**Symbol('u'),
            cirq.X(a)**Symbol('v'),
            cirq.Y(b)**Symbol('w'),
        )
>       assert circuit.is_parameterized()
E       assert False
E        +  where False = <bound method Circuit.is_parameterized of cirq.Circuit(moments=[\n    cirq.Moment(operations=[\n        (cirq.CZ**1.0*u)...(operations=[\n        (cirq.X**1.0*v).on(cirq.LineQubit(0)),\n        (cirq.Y**1.0*w).on(cirq.LineQubit(1)),\n    ]),\n])>()
E        +    where <bound method Circuit.is_parameterized of cirq.Circuit(moments=[\n    cirq.Moment(operations=[\n        (cirq.CZ**1.0*u)...(operations=[\n        (cirq.X**1.0*v).on(cirq.LineQubit(0)),\n        (cirq.Y**1.0*w).on(cirq.LineQubit(1)),\n    ]),\n])> = cirq.Circuit(moments=[\n    cirq.Moment(operations=[\n        (cirq.CZ**1.0*u).on(cirq.LineQubit(0), cirq.LineQubit(1)),...t(operations=[\n        (cirq.X**1.0*v).on(cirq.LineQubit(0)),\n        (cirq.Y**1.0*w).on(cirq.LineQubit(1)),\n    ]),\n]).is_parameterized

cirq/circuits/circuit_test.py:1617: AssertionError
_______________________ test_with_parameters_resolved_by _______________________

    def test_with_parameters_resolved_by():
        a, b = cirq.LineQubit.range(2)
        circuit = cirq.Circuit.from_ops(
            cirq.CZ(a, b)**Symbol('u'),
            cirq.X(a)**Symbol('v'),
            cirq.Y(b)**Symbol('w'),
        )
        resolved_circuit = circuit.with_parameters_resolved_by(
                cirq.ParamResolver({'u': 0.1, 'v': 0.3, 'w': 0.2}))
        cirq.testing.assert_has_diagram(resolved_circuit, """
    0: ───@───────X^0.3───
          │
    1: ───@^0.1───Y^0.2───
>   """)

cirq/circuits/circuit_test.py:1641: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = cirq.Circuit(moments=[
    cirq.Moment(operations=[
        (cirq.CZ**1.0*u).on(cirq.LineQubit(0), cirq.LineQubit(1)),...t(operations=[
        (cirq.X**1.0*v).on(cirq.LineQubit(0)),
        (cirq.Y**1.0*w).on(cirq.LineQubit(1)),
    ]),
])
desired = '\n0: ───@───────X^0.3───\n      │\n1: ───@^0.1───Y^0.2───\n'
kwargs = {}
actual_diagram = '0: ───@─────────X^1.0*v───\n      │\n1: ───@^1.0*u───Y^1.0*w───'
desired_diagram = '0: ───@───────X^0.3───\n      │\n1: ───@^0.1───Y^0.2───'

    def assert_has_diagram(
            actual: circuits.Circuit,
            desired: str,
            **kwargs) -> None:
        """Determines if a given circuit has the desired text diagram.
    
        Args:
            actual: The circuit that was actually computed by some process.
            desired: The desired text diagram as a string. Whitespace at the
                beginning and end are ignored.
            **kwargs: Keyword arguments to be passed to actual.to_text_diagram().
        """
        actual_diagram = actual.to_text_diagram(**kwargs).strip()
        desired_diagram = desired.strip()
        assert actual_diagram == desired_diagram, (
            "Circuit's text diagram differs from the desired diagram.\n"
            '\n'
            'Diagram of actual circuit:\n'
            '{}\n'
            '\n'
            'Desired text diagram:\n'
            '{}\n'
            '\n'
            'Highlighted differences:\n'
            '{}\n'.format(actual_diagram, desired_diagram,
>                         _text_diagram_diff(actual_diagram, desired_diagram))
        )
E       AssertionError: Circuit's text diagram differs from the desired diagram.
E       
E       Diagram of actual circuit:
E       0: ───@─────────X^1.0*v───
E             │
E       1: ───@^1.0*u───Y^1.0*w───
E       
E       Desired text diagram:
E       0: ───@───────X^0.3───
E             │
E       1: ───@^0.1───Y^0.2───
E       
E       Highlighted differences:
E       0: ───@───────████████████
E             │
E       1: ───@^█.███─████████████

cirq/testing/circuit_compare.py:233: AssertionError
_________________ test_ignores_czs_separated_by_parameterized __________________

    def test_ignores_czs_separated_by_parameterized():
        a, b = cirq.LineQubit.range(2)
        assert_optimizes(
            before=cirq.Circuit([
                cirq.Moment([cirq.CZ(a, b)]),
                cirq.Moment([cirq.RotZGate(
>                   half_turns=Symbol('boo'))(a)]),
                cirq.Moment([cirq.CZ(a, b)]),
            ]),
            expected=cirq.Circuit([
                cirq.Moment([cirq.CZ(a, b)]),
                cirq.Moment([cirq.RotZGate(
                    half_turns=Symbol('boo'))(a)]),
                cirq.Moment([cirq.CZ(a, b)]),
            ]))

cirq/circuits/merge_interactions_test.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*boo + 1.0, 2) - 1.0 <= -1.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
_________________________ test_depolarizer_all_errors __________________________

    def test_depolarizer_all_errors():
        q1 = cirq.QubitId()
        q2 = cirq.QubitId()
        cnot = Job(cirq.Circuit([
            cirq.Moment([cirq.CNOT(q1, q2)]),
            ]))
        all_errors = DepolarizerChannel(probability=1.0)
        p0 = Symbol(DepolarizerChannel._parameter_name + '0')
        p1 = Symbol(DepolarizerChannel._parameter_name + '1')
    
        error_sweep = cirq.Points(p0.name, [1.0]) + cirq.Points(p1.name, [1.0])
    
        cnot_then_z = Job(
            cirq.Circuit([
                cirq.Moment([cirq.CNOT(q1, q2)]),
>               cirq.Moment([xmon_gates.ExpZGate(half_turns=p0).on(q1),
                                 xmon_gates.ExpZGate(half_turns=p1).on(q2)])
            ]),
            cnot.sweep * error_sweep)

cirq/contrib/jobs/depolarizer_channel_test.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/google/xmon_gates.py:484: in __init__
    global_shift_in_half_turns=-0.5)
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*error_parameter0 + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
_______________________ test_depolarizer_different_gate ________________________

    def test_depolarizer_different_gate():
        q1 = cirq.QubitId()
        q2 = cirq.QubitId()
        cnot = Job(cirq.Circuit([
            cirq.Moment([cirq.CNOT(q1, q2)]),
            ]))
        allerrors = DepolarizerChannel(probability=1.0, depolarizing_gates=
                                       [xmon_gates.ExpZGate(),
                                        xmon_gates.ExpWGate()])
        p0 = Symbol(DepolarizerChannel._parameter_name + '0')
        p1 = Symbol(DepolarizerChannel._parameter_name + '1')
        p2 = Symbol(DepolarizerChannel._parameter_name + '2')
        p3 = Symbol(DepolarizerChannel._parameter_name + '3')
    
        error_sweep = (cirq.Points(p0.name, [1.0]) + cirq.Points(p1.name, [1.0])
                       + cirq.Points(p2.name, [1.0]) + cirq.Points(p3.name, [1.0]))
    
        cnot_then_z = Job(
            cirq.Circuit([
                cirq.Moment([cirq.CNOT(q1, q2)]),
>               cirq.Moment([xmon_gates.ExpZGate(half_turns=p0).on(q1),
                                 xmon_gates.ExpZGate(half_turns=p1).on(q2)]),
                cirq.Moment([xmon_gates.ExpWGate(half_turns=p2).on(q1),
                                 xmon_gates.ExpWGate(half_turns=p3).on(q2)])
            ]),
            cnot.sweep * error_sweep)

cirq/contrib/jobs/depolarizer_channel_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/google/xmon_gates.py:484: in __init__
    global_shift_in_half_turns=-0.5)
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*error_parameter0 + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
____________________ test_depolarizer_multiple_realizations ____________________

    def test_depolarizer_multiple_realizations():
        q1 = cirq.QubitId()
        q2 = cirq.QubitId()
        cnot = Job(cirq.Circuit([
            cirq.Moment([cirq.CNOT(q1, q2)]),
            ]))
        all_errors3 = DepolarizerChannel(probability=1.0, realizations=3)
        p0 = Symbol(DepolarizerChannel._parameter_name + '0')
        p1 = Symbol(DepolarizerChannel._parameter_name + '1')
    
        error_sweep = (cirq.Points(p0.name, [1.0, 1.0, 1.0]) +
                       cirq.Points(p1.name, [1.0, 1.0, 1.0]))
    
        cnot_then_z3 = Job(
            cirq.Circuit([
                cirq.Moment([cirq.CNOT(q1, q2)]),
>               cirq.Moment([xmon_gates.ExpZGate(half_turns=p0).on(q1),
                                 xmon_gates.ExpZGate(half_turns=p1).on(q2)])
            ]),
            cnot.sweep * error_sweep)

cirq/contrib/jobs/depolarizer_channel_test.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/google/xmon_gates.py:484: in __init__
    global_shift_in_half_turns=-0.5)
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*error_parameter0 + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
_____________________ test_depolarizer_parameterized_gates _____________________

    def test_depolarizer_parameterized_gates():
        q1 = cirq.QubitId()
        q2 = cirq.QubitId()
        cnot_param = Symbol('cnot_turns')
        cnot_gate = xmon_gates.Exp11Gate(half_turns=cnot_param).on(q1, q2)
    
        job_sweep = cirq.Points('cnot_turns', [0.5])
    
        cnot = Job(cirq.Circuit([cirq.Moment([cnot_gate])]), job_sweep)
        all_errors = DepolarizerChannel(probability=1.0)
        p0 = Symbol(DepolarizerChannel._parameter_name + '0')
        p1 = Symbol(DepolarizerChannel._parameter_name + '1')
    
        error_sweep = cirq.Points(p0.name, [1.0]) + cirq.Points(p1.name, [1.0])
        cnot_then_z = Job(
            cirq.Circuit([
                cirq.Moment([cnot_gate]),
>               cirq.Moment([xmon_gates.ExpZGate(half_turns=p0).on(q1),
                                 xmon_gates.ExpZGate(half_turns=p1).on(q2)])
            ]),
            job_sweep * error_sweep)

cirq/contrib/jobs/depolarizer_channel_test.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/google/xmon_gates.py:484: in __init__
    global_shift_in_half_turns=-0.5)
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*error_parameter0 + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
_____________________ test_extrapolate_effect_with_symbol ______________________

    def test_extrapolate_effect_with_symbol():
        eq = cirq.testing.EqualsTester()
        eq.add_equality_group(
            PauliStringPhasor(cirq.PauliString({}),
                              half_turns=Symbol('a')),
>           PauliStringPhasor(cirq.PauliString({})) ** Symbol('a'))

cirq/contrib/paulistring/pauli_string_phasor_test.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cirq.testing.equals_tester.EqualsTester object at 0x7f160d7a9b38>
group_items = (PauliStringPhasor({+, }, half_turns=a), PauliStringPhasor({+, }, half_turns=-Mod(-1.0*a + 1.0, 2) + 1))
v1 = PauliStringPhasor({+, }, half_turns=a)
v2 = PauliStringPhasor({+, }, half_turns=-Mod(-1.0*a + 1.0, 2) + 1)
same = False

    def add_equality_group(self, *group_items: Any):
        """Tries to add a disjoint equivalence group to the equality tester.
    
            This methods asserts that items within the group must all be equal to
            each other, but not equal to any items in other groups that have been
            or will be added.
    
            Args:
              *group_items: The items making up the equivalence group.
    
            Raises:
                AssertionError: Items within the group are not equal to each other,
                    or items in another group are equal to items within the new
                    group, or the items violate the equals-implies-same-hash rule.
            """
    
        assert group_items
    
        # Within-group items must be equal.
        for v1, v2 in itertools.product(group_items, group_items):
            same = EqualsTester._eq_check(v1, v2)
            assert same or v1 is not v2, "{!r} isn't equal to itself!".format(
                v1)
            assert same, (
                "{!r} and {!r} can't be in the same equality group. "
>               "They're not equal.".format(v1, v2))
E           AssertionError: PauliStringPhasor({+, }, half_turns=a) and PauliStringPhasor({+, }, half_turns=-Mod(-1.0*a + 1.0, 2) + 1) can't be in the same equality group. They're not equal.

cirq/testing/equals_tester.py:70: AssertionError
_____________________________ test_is_parametrized _____________________________

    def test_is_parametrized():
        op = PauliStringPhasor(cirq.PauliString({}))
        assert not op.is_parameterized()
        assert not (op ** 0.1).is_parameterized()
>       assert (op ** Symbol('a')).is_parameterized()
E       AssertionError: assert False
E        +  where False = <bound method PauliStringPhasor.is_parameterized of PauliStringPhasor({+, }, half_turns=-Mod(-1.0*a + 1.0, 2) + 1)>()
E        +    where <bound method PauliStringPhasor.is_parameterized of PauliStringPhasor({+, }, half_turns=-Mod(-1.0*a + 1.0, 2) + 1)> = (PauliStringPhasor({+, }, half_turns=1.0) ** a).is_parameterized
E        +      where a = Symbol('a')

cirq/contrib/paulistring/pauli_string_phasor_test.py:217: AssertionError
_____________________________ test_drop_negligible _____________________________

    def test_drop_negligible():
        q0, = _make_qubits(1)
        sym = Symbol('a')
        circuit = cirq.Circuit.from_ops(
            PauliStringPhasor(cirq.PauliString({q0: cirq.Pauli.Z})) ** 0.25,
            PauliStringPhasor(cirq.PauliString({q0: cirq.Pauli.Z})) ** 1e-10,
            PauliStringPhasor(cirq.PauliString({q0: cirq.Pauli.Z})) ** sym,
        )
        expected = cirq.Circuit.from_ops(
            PauliStringPhasor(cirq.PauliString({q0: cirq.Pauli.Z})) ** 0.25,
            PauliStringPhasor(cirq.PauliString({q0: cirq.Pauli.Z})) ** sym,
        )
>       cirq.DropNegligible().optimize_circuit(circuit)

cirq/contrib/paulistring/pauli_string_phasor_test.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/circuits/drop_negligible.py:42: in optimize_circuit
    bounded.trace_distance_bound() <= self.tolerance):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Abs(-3.5*Mod(-1.0*a + 1.0, 2) + 3.5) <= 1.0e-8

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
__________________________ test_decompose_with_symbol __________________________

    def test_decompose_with_symbol():
        q0, = _make_qubits(1)
        ps = cirq.PauliString({q0: cirq.Pauli.Y})
        op = PauliStringPhasor(ps, half_turns=Symbol('a'))
        circuit = cirq.Circuit.from_ops(op)
>       cirq.ExpandComposite().optimize_circuit(circuit)

cirq/contrib/paulistring/pauli_string_phasor_test.py:328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/circuits/optimization_pass.py:144: in optimize_circuit
    opt = self.optimization_at(circuit, i, op)
cirq/circuits/expand_composite.py:59: in optimization_at
    new_operations=decomposition)
cirq/circuits/optimization_pass.py:61: in __init__
    self.new_operations = tuple(ops.flatten_op_tree(new_operations))
cirq/ops/op_tree.py:64: in flatten_op_tree
    for subtree in root:
cirq/circuits/expand_composite.py:70: in <genexpr>
    return (self._decompose(op) for op in op_iter)
cirq/ops/op_tree.py:64: in flatten_op_tree
    for subtree in root:
cirq/contrib/paulistring/pauli_string_phasor.py:124: in default_decompose
    yield ops.RotZGate(half_turns=self.half_turns)(any_qubit)
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 1.0, 2) - 1.0 <= -1.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
________________________ test_various_known_gate_types _________________________

    def test_various_known_gate_types():
        a = cirq.NamedQubit('a')
        b = cirq.NamedQubit('b')
        circuit = cirq.Circuit.from_ops(
            cirq.google.ExpWGate(axis_half_turns=0).on(a),
            cirq.google.ExpWGate(axis_half_turns=0.5).on(a),
            cirq.X(a),
            cirq.X(a)**0.25,
            cirq.X(a)**-0.5,
            cirq.Z(a),
            cirq.Z(a)**0.5,
            cirq.Y(a),
            cirq.Y(a)**-0.25,
            cirq.Y(a)**Symbol('t'),
            cirq.H(a),
            cirq.measure(a),
            cirq.measure(a, b, key='not-relevant'),
            cirq.SWAP(a, b),
            cirq.CNOT(a, b),
            cirq.CNOT(b, a),
            cirq.CZ(a, b),
        )
>       assert circuit_to_quirk_url(circuit, escape_url=False) == """
            http://algassert.com/quirk#circuit={"cols":[
                ["X"],
                ["Y"],
                ["X"],
                ["X^¼"],
                ["X^-½"],
                ["Z"],
                ["Z^½"],
                ["Y"],
                ["Y^-¼"],
                ["Y^t"],
                ["H"],
                ["Measure"],
                ["Measure","Measure"],
                ["Swap","Swap"],
                ["•","X"],
                ["X","•"],
                ["•","Z"]]}
        """.replace('\n', '').replace(' ', '')

cirq/contrib/quirk/export_to_quirk_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/contrib/quirk/export_to_quirk.py:86: in circuit_to_quirk_url
    prefer_unknown_gate_to_failure):
cirq/contrib/quirk/export_to_quirk.py:45: in _to_quirk_cols
    gate = _try_convert_to_quirk_gate(op, prefer_unknown_gate_to_failure)
cirq/contrib/quirk/export_to_quirk.py:31: in _try_convert_to_quirk_gate
    quirk_gate = quirk_gate_ext.try_cast(QuirkOp, op)
cirq/extension/extensions.py:183: in try_cast
    cast_value = caster(self, actual_value)
cirq/contrib/quirk/quirk_gate.py:149: in <lambda>
    lambda ext, op: ext.try_cast(QuirkOp, op.gate))
cirq/extension/extensions.py:183: in try_cast
    cast_value = caster(self, actual_value)
cirq/extension/extensions.py:134: in <lambda>
    lambda _, v: conversion(v),
cirq/contrib/quirk/quirk_gate.py:96: in y_to_known
    e = angle_to_exponent_key(gate.half_turns)
cirq/contrib/quirk/quirk_gate.py:63: in angle_to_exponent_key
    if same_half_turns(t, 1):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Abs(Mod(1.0*t, 2) - 1) < 0.0001

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
_____________________ test_blocked_by_unknown_and_symbols ______________________

    def test_blocked_by_unknown_and_symbols():
        a = cirq.NamedQubit('a')
        b = cirq.NamedQubit('b')
    
        assert_optimizes(
            before=quick_circuit(
                [cg.ExpWGate().on(a)],
                [cirq.SWAP(a, b)],
                [cg.ExpWGate().on(a)],
            ),
            expected=quick_circuit(
                [cg.ExpWGate().on(a)],
                [cirq.SWAP(a, b)],
                [cg.ExpWGate().on(a)],
            ))
    
        assert_optimizes(
            before=quick_circuit(
                [cg.ExpWGate().on(a)],
>               [cg.ExpZGate(half_turns=Symbol('z')).on(a)],
                [cg.ExpWGate().on(a)],
            ),
            expected=quick_circuit(
                [cg.ExpWGate().on(a)],
                [cg.ExpZGate(half_turns=Symbol('z')).on(a)],
                [cg.ExpWGate().on(a)],
            ),
            compare_unitaries=False)

cirq/google/eject_full_w_test.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/google/xmon_gates.py:484: in __init__
    global_shift_in_half_turns=-0.5)
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*z + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
______________________________ test_symbols_block ______________________________

    def test_symbols_block():
        q = cirq.NamedQubit('q')
        assert_optimizes(
            before=cirq.Circuit([
                cirq.Moment([cg.ExpZGate(half_turns=1)(q)]),
                cirq.Moment([cg.ExpZGate(
>                   half_turns=Symbol('a'))(q)]),
                cirq.Moment([cg.ExpZGate(half_turns=0.25)(q)]),
            ]),
            expected=cirq.Circuit([
                cirq.Moment([cg.ExpZGate(
                    half_turns=Symbol('a'))(q)]),
                cirq.Moment([cg.ExpZGate(half_turns=1.25)(q)]),
            ]))

cirq/google/eject_z_test.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/google/xmon_gates.py:484: in __init__
    global_shift_in_half_turns=-0.5)
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
__________________________________ test_z_eq ___________________________________

    def test_z_eq():
        eq = cirq.testing.EqualsTester()
        eq.make_equality_group(lambda: cg.ExpZGate(half_turns=0))
        eq.add_equality_group(cg.ExpZGate(),
                              cg.ExpZGate(half_turns=1),
                              cg.ExpZGate(degs=180),
                              cg.ExpZGate(rads=np.pi))
        eq.make_equality_group(
>           lambda: cg.ExpZGate(half_turns=Symbol('a')))

cirq/google/xmon_gates_test.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/equals_tester.py:111: in make_equality_group
    self.add_equality_group(*(f() for f in factories for _ in range(2)))
cirq/testing/equals_tester.py:111: in <genexpr>
    self.add_equality_group(*(f() for f in factories for _ in range(2)))
cirq/google/xmon_gates_test.py:158: in <lambda>
    lambda: cg.ExpZGate(half_turns=Symbol('a')))
cirq/google/xmon_gates.py:484: in __init__
    global_shift_in_half_turns=-0.5)
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
__________________________ test_z_proto_dict_convert ___________________________

    def test_z_proto_dict_convert():
>       gate = cg.ExpZGate(half_turns=Symbol('k'))

cirq/google/xmon_gates_test.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/google/xmon_gates.py:484: in __init__
    global_shift_in_half_turns=-0.5)
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*k + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
_____________________________ test_z_parameterize ______________________________

    def test_z_parameterize():
>       parameterized_gate = cg.ExpZGate(half_turns=Symbol('a'))

cirq/google/xmon_gates_test.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/google/xmon_gates.py:484: in __init__
    global_shift_in_half_turns=-0.5)
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
_______________________________ test_trace_bound _______________________________

    def test_trace_bound():
        assert cg.ExpZGate(half_turns=.001).trace_distance_bound() < 0.01
        assert cg.ExpWGate(half_turns=.001).trace_distance_bound() < 0.01
>       assert cg.ExpZGate(
            half_turns=Symbol('a')).trace_distance_bound() >= 1

cirq/google/xmon_gates_test.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/google/xmon_gates.py:484: in __init__
    global_shift_in_half_turns=-0.5)
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
________________________________ test_z_inverse ________________________________

    def test_z_inverse():
>       assert cirq.inverse(cg.ExpZGate(half_turns=Symbol('a')), None) is None

cirq/google/xmon_gates_test.py:540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/google/xmon_gates.py:484: in __init__
    global_shift_in_half_turns=-0.5)
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
__________________________ test_cirq_symbol_diagrams ___________________________

    def test_cirq_symbol_diagrams():
        q00 = cirq.GridQubit(0, 0)
        q01 = cirq.GridQubit(0, 1)
        c = cirq.Circuit.from_ops(
            cg.ExpWGate(axis_half_turns=Symbol('a'),
                        half_turns=Symbol('b')).on(q00),
>           cg.ExpZGate(half_turns=Symbol('c')).on(q01),
            cg.Exp11Gate(half_turns=Symbol('d')).on(q00, q01),
        )

cirq/google/xmon_gates_test.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/google/xmon_gates.py:484: in __init__
    global_shift_in_half_turns=-0.5)
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*c + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
_____________________ test_param_resolver_exp_z_half_turns _____________________

    def test_param_resolver_exp_z_half_turns():
>       exp_z = cg.ExpZGate(half_turns=Symbol('a'))

cirq/google/sim/xmon_simulator_test.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/google/xmon_gates.py:484: in __init__
    global_shift_in_half_turns=-0.5)
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
________________________________ test_cz_matrix ________________________________

    def test_cz_matrix():
        assert np.allclose(cirq.unitary(cirq.CZ),
                           np.array([[1, 0, 0, 0],
                                     [0, 1, 0, 0],
                                     [0, 0, 1, 0],
                                     [0, 0, 0, -1]]))
    
        assert np.allclose(cirq.unitary(cirq.CZ**0.5),
                           np.array([[1, 0, 0, 0],
                                     [0, 1, 0, 0],
                                     [0, 0, 1, 0],
                                     [0, 0, 0, 1j]]))
    
        assert np.allclose(cirq.unitary(cirq.CZ**0),
                           np.array([[1, 0, 0, 0],
                                     [0, 1, 0, 0],
                                     [0, 0, 1, 0],
                                     [0, 0, 0, 1]]))
    
        assert np.allclose(cirq.unitary(cirq.CZ**-0.5),
                           np.array([[1, 0, 0, 0],
                                     [0, 1, 0, 0],
                                     [0, 0, 1, 0],
                                     [0, 0, 0, -1j]]))
    
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            val=cirq.CZ,
>           exponents=[1, 0.5, -0.25, Symbol('s')])

cirq/ops/common_gates_test.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (cirq.CZ**1.0*s)
target_tensor = array([[[[[[1.+0.j, 0.+0.j],
           [0.+0.j, 0.+0.j]],

          [[0.+0.j, 0.+0.j],
           [0.+0.j, 0.+0.j]]]...      [[[0.+0.j, 0.+0.j],
           [0.+0.j, 0.+0.j]],

          [[0.+0.j, 0.+0.j],
           [0.+0.j, 1.+0.j]]]]]])
available_buffer = array([[[[[[nan+nanj, nan+nanj],
           [nan+nanj, nan+nanj]],

          [[nan+nanj, nan+nanj],
           [nan+n...j, nan+nanj],
           [nan+nanj, nan+nanj]],

          [[nan+nanj, nan+nanj],
           [nan+nanj, nan+nanj]]]]]])
axes = [0, 1]

    def _apply_unitary_to_tensor_(self,
                                  target_tensor: np.ndarray,
                                  available_buffer: np.ndarray,
                                  axes: Sequence[int],
                                  ) -> Union[np.ndarray, type(NotImplemented)]:
        if self.is_parameterized():
            return NotImplemented
    
>       c = np.exp(1j * np.pi * self.half_turns)
E       AttributeError: 'Mul' object has no attribute 'exp'

cirq/ops/common_gates.py:73: AttributeError
________________________________ test_z_matrix _________________________________

    def test_z_matrix():
        assert np.allclose(cirq.unitary(cirq.Z),
                           np.array([[1, 0], [0, -1]]))
        assert np.allclose(cirq.unitary(cirq.Z**0.5),
                           np.array([[1, 0], [0, 1j]]))
        assert np.allclose(cirq.unitary(cirq.Z**0),
                           np.array([[1, 0], [0, 1]]))
        assert np.allclose(cirq.unitary(cirq.Z**-0.5),
                           np.array([[1, 0], [0, -1j]]))
    
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            val=cirq.Z,
>           exponents=[1, 0.5, -0.25, Symbol('s')])

cirq/ops/common_gates_test.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (cirq.Z**1.0*s)
target_tensor = array([[[[1.+0.j, 0.+0.j],
         [0.+0.j, 0.+0.j]],

        [[0.+0.j, 1.+0.j],
         [0.+0.j, 0.+0.j]]],


       [[[0.+0.j, 0.+0.j],
         [1.+0.j, 0.+0.j]],

        [[0.+0.j, 0.+0.j],
         [0.+0.j, 1.+0.j]]]])
available_buffer = array([[[[nan+nanj, nan+nanj],
         [nan+nanj, nan+nanj]],

        [[nan+nanj, nan+nanj],
         [nan+nanj, nan...[nan+nanj, nan+nanj],
         [nan+nanj, nan+nanj]],

        [[nan+nanj, nan+nanj],
         [nan+nanj, nan+nanj]]]])
axes = [0]

    def _apply_unitary_to_tensor_(self,
                                  target_tensor: np.ndarray,
                                  available_buffer: np.ndarray,
                                  axes: Sequence[int],
                                  ) -> Union[np.ndarray, type(NotImplemented)]:
        if self.is_parameterized():
            return NotImplemented
    
        one = linalg.slice_for_qubits_equal_to(axes, 1)
>       c = np.exp(1j * np.pi * self.half_turns)
E       AttributeError: 'Mul' object has no attribute 'exp'

cirq/ops/common_gates.py:318: AttributeError
________________________________ test_y_matrix _________________________________

self = 0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
        result = self.evalf()
        re, im = result.as_real_imag()
>       return complex(float(re), float(im))

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.5*re(1.0**(2.0*s)*I**(2.0*s)) + 0.5

    def __float__(self):
        # Don't bother testing if it's a number; if it's not this is going
        # to fail, and if it is we still need to check that it evalf'ed to
        # a number.
        result = self.evalf()
        if result.is_Number:
            return float(result)
        if result.is_number and result.as_real_imag()[1]:
            raise TypeError("can't convert complex to float")
>       raise TypeError("can't convert expression to float")
E       TypeError: can't convert expression to float

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:239: TypeError

The above exception was the direct cause of the following exception:

self = 0.5*I*(1.0*I)**(2.0*s) - 0.5*I

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.5*I*(1.0*I)**(2.0*s) - 0.5*I, n = 15, subs = None, maxn = 100
chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = -0.5*I*(1.0*I)**(2.0*s) + 0.5*I

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.5*I*(1.0*I)**(2.0*s) + 0.5*I, n = 15, subs = None, maxn = 100
chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

    def test_y_matrix():
        assert np.allclose(cirq.unitary(cirq.Y),
                           np.array([[0, -1j], [1j, 0]]))
    
        assert np.allclose(cirq.unitary(cirq.Y**0.5),
                           np.array([[1 + 1j, -1 - 1j], [1 + 1j, 1 + 1j]]) / 2)
    
        assert np.allclose(cirq.unitary(cirq.Y**0),
                           np.array([[1, 0], [0, 1]]))
    
        assert np.allclose(cirq.unitary(cirq.Y**-0.5),
                           np.array([[1 - 1j, 1 - 1j], [-1 + 1j, 1 - 1j]]) / 2)
    
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            val=cirq.Y,
>           exponents=[1, 0.5, -0.25, Symbol('s')])

cirq/ops/common_gates_test.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:160: in apply_unitary_to_tensor
    matrix.astype(target_tensor.dtype).reshape((2,) * (2 * len(axes))),
../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: in __complex__
    result = self.evalf()
../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: in evalf
    from sympy import Float, Number
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError
________________________________ test_x_matrix _________________________________

self = 0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
        result = self.evalf()
        re, im = result.as_real_imag()
>       return complex(float(re), float(im))

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.5*re(1.0**(2.0*s)*I**(2.0*s)) + 0.5

    def __float__(self):
        # Don't bother testing if it's a number; if it's not this is going
        # to fail, and if it is we still need to check that it evalf'ed to
        # a number.
        result = self.evalf()
        if result.is_Number:
            return float(result)
        if result.is_number and result.as_real_imag()[1]:
            raise TypeError("can't convert complex to float")
>       raise TypeError("can't convert expression to float")
E       TypeError: can't convert expression to float

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:239: TypeError

The above exception was the direct cause of the following exception:

self = -0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.5*(1.0*I)**(2.0*s) + 0.5, n = 15, subs = None, maxn = 100
chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = -0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.5*(1.0*I)**(2.0*s) + 0.5, n = 15, subs = None, maxn = 100
chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

    def test_x_matrix():
        assert np.allclose(cirq.unitary(cirq.X),
                           np.array([[0, 1], [1, 0]]))
    
        assert np.allclose(cirq.unitary(cirq.X**0.5),
                           np.array([[1 + 1j, 1 - 1j], [1 - 1j, 1 + 1j]]) / 2)
    
        assert np.allclose(cirq.unitary(cirq.X**0),
                           np.array([[1, 0], [0, 1]]))
    
        assert np.allclose(cirq.unitary(cirq.X**-0.5),
                           np.array([[1 - 1j, 1 + 1j], [1 + 1j, 1 - 1j]]) / 2)
    
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            val=cirq.X,
>           exponents=[1, 0.5, -0.25, Symbol('s')])

cirq/ops/common_gates_test.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:160: in apply_unitary_to_tensor
    matrix.astype(target_tensor.dtype).reshape((2,) * (2 * len(axes))),
../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: in __complex__
    result = self.evalf()
../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: in evalf
    from sympy import Float, Number
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError
________________________________ test_h_matrix _________________________________

self = 0.146446609406726*(1.0*I)**(2.0*s) + 0.853553390593274

    def __complex__(self):
        result = self.evalf()
        re, im = result.as_real_imag()
>       return complex(float(re), float(im))

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.146446609406726*re(1.0**(2.0*s)*I**(2.0*s)) + 0.853553390593274

    def __float__(self):
        # Don't bother testing if it's a number; if it's not this is going
        # to fail, and if it is we still need to check that it evalf'ed to
        # a number.
        result = self.evalf()
        if result.is_Number:
            return float(result)
        if result.is_number and result.as_real_imag()[1]:
            raise TypeError("can't convert complex to float")
>       raise TypeError("can't convert expression to float")
E       TypeError: can't convert expression to float

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:239: TypeError

The above exception was the direct cause of the following exception:

self = -0.353553390593274*(1.0*I)**(2.0*s) + 0.353553390593274

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.353553390593274*(1.0*I)**(2.0*s) + 0.353553390593274, n = 15
subs = None, maxn = 100, chop = False, strict = False, quad = None
verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = -0.353553390593274*(1.0*I)**(2.0*s) + 0.353553390593274

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.353553390593274*(1.0*I)**(2.0*s) + 0.353553390593274, n = 15
subs = None, maxn = 100, chop = False, strict = False, quad = None
verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

    def test_h_matrix():
        sqrt = cirq.unitary(cirq.H**0.5)
        m = np.dot(sqrt, sqrt)
        assert np.allclose(m, cirq.unitary(cirq.H), atol=1e-8)
    
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            val=cirq.H,
>           exponents=[1, 0.5, -0.25, Symbol('s')])

cirq/ops/common_gates_test.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:160: in apply_unitary_to_tensor
    matrix.astype(target_tensor.dtype).reshape((2,) * (2 * len(axes))),
../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: in __complex__
    result = self.evalf()
../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: in evalf
    from sympy import Float, Number
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError
_______________________ test_runtime_types_of_rot_gates ________________________

    def test_runtime_types_of_rot_gates():
        for gate_type in [cirq.Rot11Gate,
                          cirq.RotXGate,
                          cirq.RotYGate,
                          cirq.RotZGate]:
            ext = cirq.Extensions()
    
>           p = gate_type(half_turns=Symbol('a'))

cirq/ops/common_gates_test.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/ops/common_gates.py:57: in __init__
    degs=degs))
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 1.0, 2) - 1.0 <= -1.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
______________________________ test_text_diagrams ______________________________

    def test_text_diagrams():
        a = cirq.NamedQubit('a')
        b = cirq.NamedQubit('b')
        circuit = cirq.Circuit.from_ops(
            cirq.SWAP(a, b),
            cirq.X(a),
            cirq.Y(a),
            cirq.Z(a),
            cirq.Z(a)**Symbol('x'),
            cirq.CZ(a, b),
            cirq.CNOT(a, b),
            cirq.CNOT(b, a),
            cirq.H(a),
            cirq.ISWAP(a, b),
            cirq.ISWAP(a, b)**-1)
    
        cirq.testing.assert_has_diagram(circuit, """
    a: ───×───X───Y───Z───Z^x───@───@───X───H───iSwap───iSwap──────
          │                     │   │   │       │       │
    b: ───×─────────────────────@───X───@───────iSwap───iSwap^-1───
>   """)

cirq/ops/common_gates_test.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = cirq.Circuit(moments=[
    cirq.Moment(operations=[
        cirq.SWAP.on(cirq.NamedQubit('a'), cirq.NamedQubit('b')),
... ]),
    cirq.Moment(operations=[
        (cirq.ISWAP**-1.0).on(cirq.NamedQubit('a'), cirq.NamedQubit('b')),
    ]),
])
desired = '\na: ───×───X───Y───Z───Z^x───@───@───X───H───iSwap───iSwap──────\n      │                     │   │   │       │       │\nb: ───×─────────────────────@───X───@───────iSwap───iSwap^-1───\n'
kwargs = {}
actual_diagram = 'a: ───×───X───Y───Z───Z^1.0*x───@───@───X───H───iSwap───iSwap──────\n      │                         │   │   │       │       │\nb: ───×─────────────────────────@───X───@───────iSwap───iSwap^-1───'
desired_diagram = 'a: ───×───X───Y───Z───Z^x───@───@───X───H───iSwap───iSwap──────\n      │                     │   │   │       │       │\nb: ───×─────────────────────@───X───@───────iSwap───iSwap^-1───'

    def assert_has_diagram(
            actual: circuits.Circuit,
            desired: str,
            **kwargs) -> None:
        """Determines if a given circuit has the desired text diagram.
    
        Args:
            actual: The circuit that was actually computed by some process.
            desired: The desired text diagram as a string. Whitespace at the
                beginning and end are ignored.
            **kwargs: Keyword arguments to be passed to actual.to_text_diagram().
        """
        actual_diagram = actual.to_text_diagram(**kwargs).strip()
        desired_diagram = desired.strip()
        assert actual_diagram == desired_diagram, (
            "Circuit's text diagram differs from the desired diagram.\n"
            '\n'
            'Diagram of actual circuit:\n'
            '{}\n'
            '\n'
            'Desired text diagram:\n'
            '{}\n'
            '\n'
            'Highlighted differences:\n'
            '{}\n'.format(actual_diagram, desired_diagram,
>                         _text_diagram_diff(actual_diagram, desired_diagram))
        )
E       AssertionError: Circuit's text diagram differs from the desired diagram.
E       
E       Diagram of actual circuit:
E       a: ───×───X───Y───Z───Z^1.0*x───@───@───X───H───iSwap───iSwap──────
E             │                         │   │   │       │       │
E       b: ───×─────────────────────────@───X───@───────iSwap───iSwap^-1───
E       
E       Desired text diagram:
E       a: ───×───X───Y───Z───Z^x───@───@───X───H───iSwap───iSwap──────
E             │                     │   │   │       │       │
E       b: ───×─────────────────────@───X───@───────iSwap───iSwap^-1───
E       
E       Highlighted differences:
E       a: ───×───X───Y───Z───Z^█████───@───█───█───█████████████████──████
E             │                     █   │   │   █   █   █   █████
E       b: ───×─────────────────────█───█───█───█───███████████████████████

cirq/testing/circuit_compare.py:233: AssertionError
_______________________________ test_cnot_power ________________________________

self = 0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
        result = self.evalf()
        re, im = result.as_real_imag()
>       return complex(float(re), float(im))

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.5*re(1.0**(2.0*s)*I**(2.0*s)) + 0.5

    def __float__(self):
        # Don't bother testing if it's a number; if it's not this is going
        # to fail, and if it is we still need to check that it evalf'ed to
        # a number.
        result = self.evalf()
        if result.is_Number:
            return float(result)
        if result.is_number and result.as_real_imag()[1]:
            raise TypeError("can't convert complex to float")
>       raise TypeError("can't convert expression to float")
E       TypeError: can't convert expression to float

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:239: TypeError

The above exception was the direct cause of the following exception:

self = -0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.5*(1.0*I)**(2.0*s) + 0.5, n = 15, subs = None, maxn = 100
chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = -0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.5*(1.0*I)**(2.0*s) + 0.5, n = 15, subs = None, maxn = 100
chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

    def test_cnot_power():
        np.testing.assert_almost_equal(
            cirq.unitary(cirq.CNOT**0.5),
            np.array([
                [1, 0, 0, 0],
                [0, 1, 0, 0],
                [0, 0, 0.5+0.5j, 0.5-0.5j],
                [0, 0, 0.5-0.5j, 0.5+0.5j],
            ]))
    
        # Matrix must be consistent with decomposition.
        a = cirq.NamedQubit('a')
        b = cirq.NamedQubit('b')
        g = cirq.CNOT**0.25
        cirq.testing.assert_allclose_up_to_global_phase(
            cirq.unitary(g),
            cirq.Circuit.from_ops(g.default_decompose([a, b])).to_unitary_matrix(),
            atol=1e-8)
    
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            val=cirq.CNOT,
>           exponents=[1, 0.5, -0.25, Symbol('s')])

cirq/ops/common_gates_test.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:160: in apply_unitary_to_tensor
    matrix.astype(target_tensor.dtype).reshape((2,) * (2 * len(axes))),
../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: in __complex__
    result = self.evalf()
../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: in evalf
    from sympy import Float, Number
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError
_____________________ test_cnot_decomposes_despite_symbol ______________________

    def test_cnot_decomposes_despite_symbol():
        a = cirq.NamedQubit('a')
        b = cirq.NamedQubit('b')
>       assert cirq.CNotGate(half_turns=Symbol('x')).default_decompose([a, b])

cirq/ops/common_gates_test.py:356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/ops/common_gates.py:688: in __init__
    degs=degs))
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*x + 1.0, 2) - 1.0 <= -1.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
_______________________________ test_swap_power ________________________________

self = 0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
        result = self.evalf()
        re, im = result.as_real_imag()
>       return complex(float(re), float(im))

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.5*re(1.0**(2.0*s)*I**(2.0*s)) + 0.5

    def __float__(self):
        # Don't bother testing if it's a number; if it's not this is going
        # to fail, and if it is we still need to check that it evalf'ed to
        # a number.
        result = self.evalf()
        if result.is_Number:
            return float(result)
        if result.is_number and result.as_real_imag()[1]:
            raise TypeError("can't convert complex to float")
>       raise TypeError("can't convert expression to float")
E       TypeError: can't convert expression to float

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:239: TypeError

The above exception was the direct cause of the following exception:

self = -0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.5*(1.0*I)**(2.0*s) + 0.5, n = 15, subs = None, maxn = 100
chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = -0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.5*(1.0*I)**(2.0*s) + 0.5, n = 15, subs = None, maxn = 100
chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.5*(1.0*I)**(2.0*s) + 0.5, n = 15, subs = None, maxn = 100, chop = False
strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

    def test_swap_power():
        np.testing.assert_almost_equal(
            cirq.unitary(cirq.SWAP**0.5),
            np.array([
                [1, 0, 0, 0],
                [0, 0.5 + 0.5j, 0.5 - 0.5j, 0],
                [0, 0.5 - 0.5j, 0.5 + 0.5j, 0],
                [0, 0, 0, 1]
            ]))
    
        # Matrix must be consistent with decomposition.
        a = cirq.NamedQubit('a')
        b = cirq.NamedQubit('b')
        g = cirq.SWAP**0.25
        cirq.testing.assert_allclose_up_to_global_phase(
            cirq.unitary(g),
            cirq.Circuit.from_ops(g.default_decompose([a, b])).to_unitary_matrix(),
            atol=1e-8)
    
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            val=cirq.SWAP,
>           exponents=[1, 0.5, -0.25, Symbol('s')])

cirq/ops/common_gates_test.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:160: in apply_unitary_to_tensor
    matrix.astype(target_tensor.dtype).reshape((2,) * (2 * len(axes))),
../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: in __complex__
    result = self.evalf()
../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: in evalf
    from sympy import Float, Number
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError
______________________________ test_iswap_matrix _______________________________

self = 0.5*(1.0*I)**(1.0*s) + 0.5*(1.0*I)**(-1.0*s)

    def __complex__(self):
        result = self.evalf()
        re, im = result.as_real_imag()
>       return complex(float(re), float(im))

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.5*re(1.0**(-1.0*s)*I**(-1.0*s)) + 0.5*re(1.0**(1.0*s)*I**(1.0*s))

    def __float__(self):
        # Don't bother testing if it's a number; if it's not this is going
        # to fail, and if it is we still need to check that it evalf'ed to
        # a number.
        result = self.evalf()
        if result.is_Number:
            return float(result)
        if result.is_number and result.as_real_imag()[1]:
            raise TypeError("can't convert complex to float")
>       raise TypeError("can't convert expression to float")
E       TypeError: can't convert expression to float

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:239: TypeError

The above exception was the direct cause of the following exception:

self = 0.5*(1.0*I)**(1.0*s) - 0.5*(1.0*I)**(-1.0*s)

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.5*(1.0*I)**(1.0*s) - 0.5*(1.0*I)**(-1.0*s), n = 15, subs = None
maxn = 100, chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0.5*(1.0*I)**(1.0*s) - 0.5*(1.0*I)**(-1.0*s)

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.5*(1.0*I)**(1.0*s) - 0.5*(1.0*I)**(-1.0*s), n = 15, subs = None
maxn = 100, chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0.5*(1.0*I)**(1.0*s) + 0.5*(1.0*I)**(-1.0*s)

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.5*(1.0*I)**(1.0*s) + 0.5*(1.0*I)**(-1.0*s), n = 15, subs = None
maxn = 100, chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

    def test_iswap_matrix():
        cirq.testing.assert_allclose_up_to_global_phase(
            cirq.unitary(cirq.ISWAP),
            np.array([[1, 0, 0, 0],
                      [0, 0, 1j, 0],
                      [0, 1j, 0, 0],
                      [0, 0, 0, 1]]),
            atol=1e-8)
    
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            val=cirq.ISWAP,
>           exponents=[1, 0.5, -0.25, Symbol('s')])

cirq/ops/common_gates_test.py:535: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:160: in apply_unitary_to_tensor
    matrix.astype(target_tensor.dtype).reshape((2,) * (2 * len(axes))),
../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: in __complex__
    result = self.evalf()
../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: in evalf
    from sympy import Float, Number
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError
_________________________________ test_unitary _________________________________

    def test_unitary():
        cxa = cirq.ControlledGate(cirq.X**Symbol('a'))
>       assert cirq.unitary(cxa, None) is None
E       assert array([[1.0, 0.0, 0, 0],\n       [0.0, 1.0, 0, 0],\n       [0, 0, 0.5*(1.0*I)**(2.0*a) + 0.5, -0.5*(1.0*I)**(2.0*a) + 0.5],\n       [0, 0, -0.5*(1.0*I)**(2.0*a) + 0.5, 0.5*(1.0*I)**(2.0*a) + 0.5]],\n      dtype=object) is None
E        +  where array([[1.0, 0.0, 0, 0],\n       [0.0, 1.0, 0, 0],\n       [0, 0, 0.5*(1.0*I)**(2.0*a) + 0.5, -0.5*(1.0*I)**(2.0*a) + 0.5],\n       [0, 0, -0.5*(1.0*I)**(2.0*a) + 0.5, 0.5*(1.0*I)**(2.0*a) + 0.5]],\n      dtype=object) = <function unitary at 0x7f16309be488>(cirq.ControlledGate(sub_gate=(cirq.X**1.0*a)), None)
E        +    where <function unitary at 0x7f16309be488> = cirq.unitary

cirq/ops/controlled_gate_test.py:77: AssertionError
_____________________ test_apply_unitary_to_tensor[gate0] ______________________

self = 0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
        result = self.evalf()
        re, im = result.as_real_imag()
>       return complex(float(re), float(im))

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.5*re(1.0**(2.0*s)*I**(2.0*s)) + 0.5

    def __float__(self):
        # Don't bother testing if it's a number; if it's not this is going
        # to fail, and if it is we still need to check that it evalf'ed to
        # a number.
        result = self.evalf()
        if result.is_Number:
            return float(result)
        if result.is_number and result.as_real_imag()[1]:
            raise TypeError("can't convert complex to float")
>       raise TypeError("can't convert expression to float")
E       TypeError: can't convert expression to float

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:239: TypeError

The above exception was the direct cause of the following exception:

self = -0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.5*(1.0*I)**(2.0*s) + 0.5, n = 15, subs = None, maxn = 100
chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = -0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.5*(1.0*I)**(2.0*s) + 0.5, n = 15, subs = None, maxn = 100
chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

gate = cirq.X

    @pytest.mark.parametrize('gate', [
        cirq.X,
        cirq.Z,
        cirq.H,
        cirq.CNOT,
        cirq.SWAP,
        cirq.CCZ,
        cirq.ControlledGate(cirq.ControlledGate(cirq.CCZ)),
        GateUsingWorkspaceForApplyUnitary(),
        GateAllocatingNewSpaceForResult(),
    ])
    def test_apply_unitary_to_tensor(gate: cirq.Gate):
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            cirq.ControlledGate(gate),
>           exponents=[1, 0.5, Symbol('s')])

cirq/ops/controlled_gate_test.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
cirq/ops/controlled_gate.py:98: in _apply_unitary_to_tensor_
    default=NotImplemented)
cirq/protocols/apply_unitary_to_tensor.py:160: in apply_unitary_to_tensor
    matrix.astype(target_tensor.dtype).reshape((2,) * (2 * len(axes))),
../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: in __complex__
    result = self.evalf()
../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: in evalf
    from sympy import Float, Number
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError
_____________________ test_apply_unitary_to_tensor[gate1] ______________________

gate = cirq.Z

    @pytest.mark.parametrize('gate', [
        cirq.X,
        cirq.Z,
        cirq.H,
        cirq.CNOT,
        cirq.SWAP,
        cirq.CCZ,
        cirq.ControlledGate(cirq.ControlledGate(cirq.CCZ)),
        GateUsingWorkspaceForApplyUnitary(),
        GateAllocatingNewSpaceForResult(),
    ])
    def test_apply_unitary_to_tensor(gate: cirq.Gate):
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            cirq.ControlledGate(gate),
>           exponents=[1, 0.5, Symbol('s')])

cirq/ops/controlled_gate_test.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
cirq/ops/controlled_gate.py:98: in _apply_unitary_to_tensor_
    default=NotImplemented)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (cirq.Z**1.0*s)
target_tensor = array([[[[[0.+0.j, 0.+0.j],
          [0.+0.j, 0.+0.j]],

         [[1.+0.j, 0.+0.j],
          [0.+0.j, 0.+0.j]]],


...

        [[[0.+0.j, 0.+0.j],
          [0.+0.j, 0.+0.j]],

         [[0.+0.j, 0.+0.j],
          [0.+0.j, 1.+0.j]]]]])
available_buffer = array([[[[[nan+nanj, nan+nanj],
          [nan+nanj, nan+nanj]],

         [[nan+nanj, nan+nanj],
          [nan+nanj,...+nanj, nan+nanj],
          [nan+nanj, nan+nanj]],

         [[nan+nanj, nan+nanj],
          [nan+nanj, nan+nanj]]]]])
axes = [0]

    def _apply_unitary_to_tensor_(self,
                                  target_tensor: np.ndarray,
                                  available_buffer: np.ndarray,
                                  axes: Sequence[int],
                                  ) -> Union[np.ndarray, type(NotImplemented)]:
        if self.is_parameterized():
            return NotImplemented
    
        one = linalg.slice_for_qubits_equal_to(axes, 1)
>       c = np.exp(1j * np.pi * self.half_turns)
E       AttributeError: 'Mul' object has no attribute 'exp'

cirq/ops/common_gates.py:318: AttributeError
_____________________ test_apply_unitary_to_tensor[gate2] ______________________

self = 0.146446609406726*(1.0*I)**(2.0*s) + 0.853553390593274

    def __complex__(self):
        result = self.evalf()
        re, im = result.as_real_imag()
>       return complex(float(re), float(im))

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.146446609406726*re(1.0**(2.0*s)*I**(2.0*s)) + 0.853553390593274

    def __float__(self):
        # Don't bother testing if it's a number; if it's not this is going
        # to fail, and if it is we still need to check that it evalf'ed to
        # a number.
        result = self.evalf()
        if result.is_Number:
            return float(result)
        if result.is_number and result.as_real_imag()[1]:
            raise TypeError("can't convert complex to float")
>       raise TypeError("can't convert expression to float")
E       TypeError: can't convert expression to float

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:239: TypeError

The above exception was the direct cause of the following exception:

self = -0.353553390593274*(1.0*I)**(2.0*s) + 0.353553390593274

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.353553390593274*(1.0*I)**(2.0*s) + 0.353553390593274, n = 15
subs = None, maxn = 100, chop = False, strict = False, quad = None
verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = -0.353553390593274*(1.0*I)**(2.0*s) + 0.353553390593274

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.353553390593274*(1.0*I)**(2.0*s) + 0.353553390593274, n = 15
subs = None, maxn = 100, chop = False, strict = False, quad = None
verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

gate = cirq.H

    @pytest.mark.parametrize('gate', [
        cirq.X,
        cirq.Z,
        cirq.H,
        cirq.CNOT,
        cirq.SWAP,
        cirq.CCZ,
        cirq.ControlledGate(cirq.ControlledGate(cirq.CCZ)),
        GateUsingWorkspaceForApplyUnitary(),
        GateAllocatingNewSpaceForResult(),
    ])
    def test_apply_unitary_to_tensor(gate: cirq.Gate):
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            cirq.ControlledGate(gate),
>           exponents=[1, 0.5, Symbol('s')])

cirq/ops/controlled_gate_test.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
cirq/ops/controlled_gate.py:98: in _apply_unitary_to_tensor_
    default=NotImplemented)
cirq/protocols/apply_unitary_to_tensor.py:160: in apply_unitary_to_tensor
    matrix.astype(target_tensor.dtype).reshape((2,) * (2 * len(axes))),
../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: in __complex__
    result = self.evalf()
../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: in evalf
    from sympy import Float, Number
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError
_____________________ test_apply_unitary_to_tensor[gate3] ______________________

self = 0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
        result = self.evalf()
        re, im = result.as_real_imag()
>       return complex(float(re), float(im))

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.5*re(1.0**(2.0*s)*I**(2.0*s)) + 0.5

    def __float__(self):
        # Don't bother testing if it's a number; if it's not this is going
        # to fail, and if it is we still need to check that it evalf'ed to
        # a number.
        result = self.evalf()
        if result.is_Number:
            return float(result)
        if result.is_number and result.as_real_imag()[1]:
            raise TypeError("can't convert complex to float")
>       raise TypeError("can't convert expression to float")
E       TypeError: can't convert expression to float

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:239: TypeError

The above exception was the direct cause of the following exception:

self = -0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.5*(1.0*I)**(2.0*s) + 0.5, n = 15, subs = None, maxn = 100
chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = -0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.5*(1.0*I)**(2.0*s) + 0.5, n = 15, subs = None, maxn = 100
chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

gate = cirq.CNOT

    @pytest.mark.parametrize('gate', [
        cirq.X,
        cirq.Z,
        cirq.H,
        cirq.CNOT,
        cirq.SWAP,
        cirq.CCZ,
        cirq.ControlledGate(cirq.ControlledGate(cirq.CCZ)),
        GateUsingWorkspaceForApplyUnitary(),
        GateAllocatingNewSpaceForResult(),
    ])
    def test_apply_unitary_to_tensor(gate: cirq.Gate):
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            cirq.ControlledGate(gate),
>           exponents=[1, 0.5, Symbol('s')])

cirq/ops/controlled_gate_test.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
cirq/ops/controlled_gate.py:98: in _apply_unitary_to_tensor_
    default=NotImplemented)
cirq/protocols/apply_unitary_to_tensor.py:160: in apply_unitary_to_tensor
    matrix.astype(target_tensor.dtype).reshape((2,) * (2 * len(axes))),
../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: in __complex__
    result = self.evalf()
../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: in evalf
    from sympy import Float, Number
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError
_____________________ test_apply_unitary_to_tensor[gate4] ______________________

self = 0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
        result = self.evalf()
        re, im = result.as_real_imag()
>       return complex(float(re), float(im))

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.5*re(1.0**(2.0*s)*I**(2.0*s)) + 0.5

    def __float__(self):
        # Don't bother testing if it's a number; if it's not this is going
        # to fail, and if it is we still need to check that it evalf'ed to
        # a number.
        result = self.evalf()
        if result.is_Number:
            return float(result)
        if result.is_number and result.as_real_imag()[1]:
            raise TypeError("can't convert complex to float")
>       raise TypeError("can't convert expression to float")
E       TypeError: can't convert expression to float

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:239: TypeError

The above exception was the direct cause of the following exception:

self = -0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.5*(1.0*I)**(2.0*s) + 0.5, n = 15, subs = None, maxn = 100
chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = -0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = -0.5*(1.0*I)**(2.0*s) + 0.5, n = 15, subs = None, maxn = 100
chop = False, strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0.5*(1.0*I)**(2.0*s) + 0.5

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0.5*(1.0*I)**(2.0*s) + 0.5, n = 15, subs = None, maxn = 100, chop = False
strict = False, quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

self = 0

    def __complex__(self):
>       result = self.evalf()

../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, n = 15, subs = None, maxn = 100, chop = False, strict = False
quad = None, verbose = False

    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
        """
            Evaluate the given formula to an accuracy of n digits.
            Optional keyword arguments:
    
                subs=<dict>
                    Substitute numerical values for symbols, e.g.
                    subs={x:3, y:1+pi}. The substitutions must be given as a
                    dictionary.
    
                maxn=<integer>
                    Allow a maximum temporary working precision of maxn digits
                    (default=100)
    
                chop=<bool>
                    Replace tiny real or imaginary parts in subresults
                    by exact zeros (default=False)
    
                strict=<bool>
                    Raise PrecisionExhausted if any subresult fails to evaluate
                    to full accuracy, given the available maxprec
                    (default=False)
    
                quad=<str>
                    Choose algorithm for numerical quadrature. By default,
                    tanh-sinh quadrature is used. For oscillatory
                    integrals on an infinite interval, try quad='osc'.
    
                verbose=<bool>
                    Print debug information (default=False)
    
            """
>       from sympy import Float, Number

../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError

The above exception was the direct cause of the following exception:

gate = cirq.SWAP

    @pytest.mark.parametrize('gate', [
        cirq.X,
        cirq.Z,
        cirq.H,
        cirq.CNOT,
        cirq.SWAP,
        cirq.CCZ,
        cirq.ControlledGate(cirq.ControlledGate(cirq.CCZ)),
        GateUsingWorkspaceForApplyUnitary(),
        GateAllocatingNewSpaceForResult(),
    ])
    def test_apply_unitary_to_tensor(gate: cirq.Gate):
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            cirq.ControlledGate(gate),
>           exponents=[1, 0.5, Symbol('s')])

cirq/ops/controlled_gate_test.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
cirq/ops/controlled_gate.py:98: in _apply_unitary_to_tensor_
    default=NotImplemented)
cirq/protocols/apply_unitary_to_tensor.py:160: in apply_unitary_to_tensor
    matrix.astype(target_tensor.dtype).reshape((2,) * (2 * len(axes))),
../anaconda3/lib/python3.6/site-packages/sympy/core/expr.py:242: in __complex__
    result = self.evalf()
../anaconda3/lib/python3.6/site-packages/sympy/core/evalf.py:1370: in evalf
    from sympy import Float, Number
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = <module 'sympy' from '/home/vtomole/anaconda3/lib/python3.6/site-packages/sympy/__init__.py'>
fromlist = ('Float', 'Number'), import_ = <built-in function __import__>

>   ???
E   SystemError: <built-in function hasattr> returned a result with an error set

<frozen importlib._bootstrap>:1007: SystemError
_____________________ test_apply_unitary_to_tensor[gate5] ______________________

gate = cirq.CCZ

    @pytest.mark.parametrize('gate', [
        cirq.X,
        cirq.Z,
        cirq.H,
        cirq.CNOT,
        cirq.SWAP,
        cirq.CCZ,
        cirq.ControlledGate(cirq.ControlledGate(cirq.CCZ)),
        GateUsingWorkspaceForApplyUnitary(),
        GateAllocatingNewSpaceForResult(),
    ])
    def test_apply_unitary_to_tensor(gate: cirq.Gate):
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            cirq.ControlledGate(gate),
>           exponents=[1, 0.5, Symbol('s')])

cirq/ops/controlled_gate_test.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
cirq/ops/controlled_gate.py:98: in _apply_unitary_to_tensor_
    default=NotImplemented)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = cirq.CCZ**1.0*s
target_tensor = array([[[[[[[[[0.+0.j, 0.+0.j],
              [0.+0.j, 0.+0.j]],

             [[0.+0.j, 0.+0.j],
              [0.+0....0.j, 0.+0.j],
              [0.+0.j, 0.+0.j]],

             [[0.+0.j, 0.+0.j],
              [0.+0.j, 1.+0.j]]]]]]]]])
available_buffer = array([[[[[[[[[nan+nanj, nan+nanj],
              [nan+nanj, nan+nanj]],

             [[nan+nanj, nan+nanj],
        ...,
              [nan+nanj, nan+nanj]],

             [[nan+nanj, nan+nanj],
              [nan+nanj, nan+nanj]]]]]]]]])
axes = [0, 1, 2]

    def _apply_unitary_to_tensor_(self,
                                  target_tensor: np.ndarray,
                                  available_buffer: np.ndarray,
                                  axes: Sequence[int],
                                  ) -> np.ndarray:
        if self.is_parameterized():
            return NotImplemented
        ooo = linalg.slice_for_qubits_equal_to(axes, 0b111)
>       target_tensor[ooo] *= np.exp(1j * self.exponent * np.pi)
E       AttributeError: 'Mul' object has no attribute 'exp'

cirq/ops/three_qubit_gates.py:98: AttributeError
_____________________ test_apply_unitary_to_tensor[gate6] ______________________

gate = cirq.ControlledGate(sub_gate=cirq.ControlledGate(sub_gate=cirq.CCZ))

    @pytest.mark.parametrize('gate', [
        cirq.X,
        cirq.Z,
        cirq.H,
        cirq.CNOT,
        cirq.SWAP,
        cirq.CCZ,
        cirq.ControlledGate(cirq.ControlledGate(cirq.CCZ)),
        GateUsingWorkspaceForApplyUnitary(),
        GateAllocatingNewSpaceForResult(),
    ])
    def test_apply_unitary_to_tensor(gate: cirq.Gate):
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            cirq.ControlledGate(gate),
>           exponents=[1, 0.5, Symbol('s')])

cirq/ops/controlled_gate_test.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
cirq/ops/controlled_gate.py:98: in _apply_unitary_to_tensor_
    default=NotImplemented)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
cirq/ops/controlled_gate.py:98: in _apply_unitary_to_tensor_
    default=NotImplemented)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
cirq/ops/controlled_gate.py:98: in _apply_unitary_to_tensor_
    default=NotImplemented)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = cirq.CCZ**1.0*s
target_tensor = array([[[[[[[[[[[0.+0.j, 0.+0.j],
                [0.+0.j, 0.+0.j]],

               [[0.+0.j, 0.+0.j],
              ...0.j],
                [0.+0.j, 0.+0.j]],

               [[0.+0.j, 0.+0.j],
                [0.+0.j, 1.+0.j]]]]]]]]]]])
available_buffer = array([[[[[[[[[[[nan+nanj, nan+nanj],
                [nan+nanj, nan+nanj]],

               [[nan+nanj, nan+nanj],
  ...          [nan+nanj, nan+nanj]],

               [[nan+nanj, nan+nanj],
                [nan+nanj, nan+nanj]]]]]]]]]]])
axes = [0, 1, 2]

    def _apply_unitary_to_tensor_(self,
                                  target_tensor: np.ndarray,
                                  available_buffer: np.ndarray,
                                  axes: Sequence[int],
                                  ) -> np.ndarray:
        if self.is_parameterized():
            return NotImplemented
        ooo = linalg.slice_for_qubits_equal_to(axes, 0b111)
>       target_tensor[ooo] *= np.exp(1j * self.exponent * np.pi)
E       AttributeError: 'Mul' object has no attribute 'exp'

cirq/ops/three_qubit_gates.py:98: AttributeError
_____________________________ test_parameterizable _____________________________

    def test_parameterizable():
        a = Symbol('a')
        cz = cirq.ControlledGate(cirq.RotYGate(half_turns=1))
>       cza = cirq.ControlledGate(cirq.RotYGate(half_turns=a))

cirq/ops/controlled_gate_test.py:231: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/ops/common_gates.py:228: in __init__
    degs=degs))
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 1.0, 2) - 1.0 <= -1.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
__________________________________ test_init ___________________________________

    def test_init():
        assert CExpZinGate(1).exponent == 1
        assert CExpZinGate(0.5).exponent == 0.5
        assert CExpZinGate(4.5).exponent == 0.5
        assert CExpZinGate(1.5).exponent == 1.5
        assert CExpZinGate(3.5).exponent == -0.5
>       assert CExpZinGate(Symbol('a')).exponent == Symbol('a')

cirq/ops/eigen_gate_test.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/ops/eigen_gate_test.py:32: in __init__
    super().__init__(exponent=quarter_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
__________________________ test_trace_distance_bound ___________________________

    def test_trace_distance_bound():
        assert CExpZinGate(0.001).trace_distance_bound() < 0.01
>       assert CExpZinGate(Symbol('a')).trace_distance_bound() >= 1

cirq/ops/eigen_gate_test.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/ops/eigen_gate_test.py:32: in __init__
    super().__init__(exponent=quarter_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
_______________________________ test_try_cast_to _______________________________

    def test_try_cast_to():
        ext = cirq.Extensions()
    
        h = CExpZinGate(2)
        assert h.try_cast_to(cirq.ExtrapolatableEffect, ext) is h
        assert h.try_cast_to(cirq.SingleQubitGate, ext) is None
        assert cirq.inverse(h, None) is not None
    
        p = CExpZinGate(0.1)
        assert p.try_cast_to(cirq.ExtrapolatableEffect, ext) is p
        assert p.try_cast_to(cirq.SingleQubitGate, ext) is None
        assert cirq.inverse(p) is not None
    
>       s = CExpZinGate(Symbol('a'))

cirq/ops/eigen_gate_test.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/ops/eigen_gate_test.py:32: in __init__
    super().__init__(exponent=quarter_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
_________________________________ test_matrix __________________________________

    def test_matrix():
        np.testing.assert_allclose(
            cirq.unitary(CExpZinGate(1)),
            np.diag([1, 1, 1j, -1j]),
            atol=1e-8)
    
        np.testing.assert_allclose(
            cirq.unitary(CExpZinGate(2)),
            np.diag([1, 1, -1, -1]),
            atol=1e-8)
    
        np.testing.assert_allclose(
            cirq.unitary(CExpZinGate(3)),
            np.diag([1, 1, -1j, 1j]),
            atol=1e-8)
    
        np.testing.assert_allclose(
            cirq.unitary(CExpZinGate(4)),
            np.diag([1, 1, 1, 1]),
            atol=1e-8)
    
        np.testing.assert_allclose(
            cirq.unitary(CExpZinGate(0.00001)),
            cirq.unitary(CExpZinGate(3.99999)),
            atol=1e-4)
    
        assert not np.allclose(
            cirq.unitary(CExpZinGate(0.00001)),
            cirq.unitary(CExpZinGate(1.99999)),
            atol=1e-4)
    
>       assert cirq.unitary(CExpZinGate(Symbol('a')), None) is None

cirq/ops/eigen_gate_test.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/ops/eigen_gate_test.py:32: in __init__
    super().__init__(exponent=quarter_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
____________________________ test_is_parameterized _____________________________

    def test_is_parameterized():
        assert not CExpZinGate(0).is_parameterized()
        assert not CExpZinGate(1).is_parameterized()
        assert not CExpZinGate(3).is_parameterized()
>       assert CExpZinGate(Symbol('a')).is_parameterized()

cirq/ops/eigen_gate_test.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/ops/eigen_gate_test.py:32: in __init__
    super().__init__(exponent=quarter_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
_______________________ test_with_parameters_resolved_by _______________________

    def test_with_parameters_resolved_by():
>       assert CExpZinGate(Symbol('a')).with_parameters_resolved_by(
            cirq.ParamResolver({'a': 0.5})) == CExpZinGate(0.5)

cirq/ops/eigen_gate_test.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/ops/eigen_gate_test.py:32: in __init__
    super().__init__(exponent=quarter_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 2.0, 4) - 2.0 <= -2.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
_________________________ test_parameterizable_effect __________________________

    def test_parameterizable_effect():
        q = cirq.NamedQubit('q')
        r = cirq.ParamResolver({'a': 0.5})
    
        # If the gate isn't parameterizable, you get a type error.
        op0 = cirq.GateOperation(cirq.Gate(), [q])
        assert not cirq.can_cast(cirq.ParameterizableEffect, op0)
        with pytest.raises(TypeError):
            _ = op0.is_parameterized()
        with pytest.raises(TypeError):
            _ = op0.with_parameters_resolved_by(r)
    
>       op1 = cirq.GateOperation(cirq.RotZGate(half_turns=Symbol('a')), [q])

cirq/ops/gate_operation_test.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/ops/common_gates.py:307: in __init__
    global_shift_in_half_turns=global_shift_in_half_turns)
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*a + 1.0, 2) - 1.0 <= -1.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
________________________ test_decomposes_despite_symbol ________________________

    def test_decomposes_despite_symbol():
        q0, q1 = cirq.NamedQubit('q0'), cirq.NamedQubit('q1')
        gate = cirq.PauliInteractionGate(cirq.Pauli.Z, False, cirq.Pauli.X, False,
>                                        half_turns=Symbol('x'))

cirq/ops/pauli_interaction_gate_test.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/ops/pauli_interaction_gate.py:63: in __init__
    degs=degs))
cirq/ops/eigen_gate.py:94: in __init__
    if exponent <= -period / 2:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Mod(1.0*x + 1.0, 2) - 1.0 <= -1.0

    def __nonzero__(self):
>       raise TypeError("cannot determine truth value of Relational")
E       TypeError: cannot determine truth value of Relational

../anaconda3/lib/python3.6/site-packages/sympy/core/relational.py:195: TypeError
_________________________________ test_matrix __________________________________

    def test_matrix():
        np.testing.assert_allclose(cirq.unitary(cirq.CCX), np.array([
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 1, 0],
        ]), atol=1e-8)
    
        np.testing.assert_allclose(cirq.unitary(cirq.CCX**0.5), np.array([
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0.5 + 0.5j, 0.5 - 0.5j],
            [0, 0, 0, 0, 0, 0, 0.5 - 0.5j, 0.5 + 0.5j],
        ]), atol=1e-8)
    
        np.testing.assert_allclose(cirq.unitary(cirq.CCZ),
                                   np.diag([1, 1, 1, 1, 1, 1, 1, -1]),
                                   atol=1e-8)
    
        np.testing.assert_allclose(cirq.unitary(cirq.CCZ**0.5),
                                   np.diag([1, 1, 1, 1, 1, 1, 1, 1j]),
                                   atol=1e-8)
    
        np.testing.assert_allclose(cirq.unitary(cirq.CSWAP), np.array([
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 0],
            [0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1],
        ]), atol=1e-8)
    
        cirq.testing.assert_apply_unitary_to_tensor_is_consistent_with_unitary(
            cirq.CCZ,
>           exponents=[1, 0.5, -0.25, Symbol('s')])

cirq/ops/three_qubit_gates_test.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cirq/testing/circuit_compare.py:267: in assert_apply_unitary_to_tensor_is_consistent_with_unitary
    default=None)
cirq/protocols/apply_unitary_to_tensor.py:152: in apply_unitary_to_tensor
    result = getter(target_tensor, available_buffer, axes)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = cirq.CCZ**1.0*s
target_tensor = array([[[[[[[[1.+0.j, 0.+0.j],
             [0.+0.j, 0.+0.j]],

            [[0.+0.j, 0.+0.j],
             [0.+0.j, 0...[0.+0.j, 0.+0.j],
             [0.+0.j, 0.+0.j]],

            [[0.+0.j, 0.+0.j],
             [0.+0.j, 1.+0.j]]]]]]]])
available_buffer = array([[[[[[[[nan+nanj, nan+nanj],
             [nan+nanj, nan+nanj]],

            [[nan+nanj, nan+nanj],
           ...anj],
             [nan+nanj, nan+nanj]],

            [[nan+nanj, nan+nanj],
             [nan+nanj, nan+nanj]]]]]]]])
axes = [0, 1, 2]

    def _apply_unitary_to_tensor_(self,
                                  target_tensor: np.ndarray,
                                  available_buffer: np.ndarray,
                                  axes: Sequence[int],
                                  ) -> np.ndarray:
        if self.is_parameterized():
            return NotImplemented
        ooo = linalg.slice_for_qubits_equal_to(axes, 0b111)
>       target_tensor[ooo] *= np.exp(1j * self.exponent * np.pi)
E       AttributeError: 'Mul' object has no attribute 'exp'

cirq/ops/three_qubit_gates.py:98: AttributeError
_____ test_can_run_docs_code_snippets[/home/vtomole/Cirq/docs/tutorial.md] _____

path = '/home/vtomole/Cirq/docs/tutorial.md'

    @pytest.mark.parametrize('path', find_docs_code_snippets_paths())
    def test_can_run_docs_code_snippets(path):
>       assert_file_has_working_code_snippets(path, assume_import=True)

docs/snippets_test.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
docs/snippets_test.py:171: in assert_file_has_working_code_snippets
    assert_code_snippets_run_in_sequence(snippets, assume_import)
docs/snippets_test.py:188: in assert_code_snippets_run_in_sequence
    assert_code_snippet_executes_correctly(content, state, line_number)
docs/snippets_test.py:284: in assert_code_snippet_executes_correctly
    assert_code_snippet_runs_and_prints_expected(before, state, line_number)
docs/snippets_test.py:326: in assert_code_snippet_runs_and_prints_expected
    exec(snippet, state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   NameError: name 'Symbol' is not defined

<string>:3: NameError
=================== 51 failed, 5089 passed in 66.62 seconds ====================
