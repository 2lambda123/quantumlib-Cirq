"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

# Identifies a qubit.
class Qubit(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ROW_FIELD_NUMBER: builtins.int
    COL_FIELD_NUMBER: builtins.int
    # row number in grid.
    row: builtins.int = ...
    # column number in grid.
    col: builtins.int = ...
    def __init__(self,
        *,
        row : builtins.int = ...,
        col : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"col",b"col",u"row",b"row"]) -> None: ...
global___Qubit = Qubit

# A number specified as a constant plus an optional parameter lookup.
class ParameterizedFloat(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RAW_FIELD_NUMBER: builtins.int
    PARAMETER_KEY_FIELD_NUMBER: builtins.int
    # A constant value.
    raw: builtins.float = ...
    # A variable value stored under some parameter key.
    # This cannot be the empty string.
    parameter_key: typing.Text = ...
    def __init__(self,
        *,
        raw : builtins.float = ...,
        parameter_key : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"parameter_key",b"parameter_key",u"raw",b"raw",u"value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"parameter_key",b"parameter_key",u"raw",b"raw",u"value",b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"value",b"value"]) -> typing.Optional[typing_extensions.Literal["raw","parameter_key"]]: ...
global___ParameterizedFloat = ParameterizedFloat

# A single-qubit rotation around an axis on the XY equator of the Bloch sphere.
#
# This gate is exp(-i * pi * W(theta) * t / 2) where
#   W(theta) = cos(pi * theta) X + sin(pi * theta) Y
# or in matrix form
#   W(theta) = [[0, cos(pi * theta) - i sin(pi * theta)],
#               [cos(pi * theta) + i sin(pi * theta), 0]]
class ExpW(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TARGET_FIELD_NUMBER: builtins.int
    AXIS_HALF_TURNS_FIELD_NUMBER: builtins.int
    HALF_TURNS_FIELD_NUMBER: builtins.int
    # The qubit to rotate.
    @property
    def target(self) -> global___Qubit: ...
    # The angle of the rotation axis' facing in the XY plane, expressed in
    # units of pi. In other words, this is the theta in exp(i pi W(theta) t / 2).
    #    - 0 is positive-ward along X.
    #    - 0.5 is positive-ward along Y.
    #    - 1.0 is negative-ward along X.
    #    - 1.5 is negative-ward along Y.
    # Note that this is periodic with period 2.
    @property
    def axis_half_turns(self) -> global___ParameterizedFloat: ...
    # The amount to rotate by expressed in units of pi / 2, i.e. the t in
    # exp(i pi W(theta) t / 2).
    # Note that this is periodic with period 4 (or 2 when ignoring global phase).
    @property
    def half_turns(self) -> global___ParameterizedFloat: ...
    def __init__(self,
        *,
        target : typing.Optional[global___Qubit] = ...,
        axis_half_turns : typing.Optional[global___ParameterizedFloat] = ...,
        half_turns : typing.Optional[global___ParameterizedFloat] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"axis_half_turns",b"axis_half_turns",u"half_turns",b"half_turns",u"target",b"target"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"axis_half_turns",b"axis_half_turns",u"half_turns",b"half_turns",u"target",b"target"]) -> None: ...
global___ExpW = ExpW

# A single-qubit rotation around the Z axis of the Bloch sphere.
#
# This gate is exp(-i * pi * Z * t / 2) where Z is the Pauli Z matrix,
#   Z = [[1, 0], [0, -1]]
class ExpZ(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TARGET_FIELD_NUMBER: builtins.int
    HALF_TURNS_FIELD_NUMBER: builtins.int
    # The qubit to rotate.
    @property
    def target(self) -> global___Qubit: ...
    # The amount of the rotation in radians, i.e. the t in
    # exp(i * pi * Z * t / 2).
    # Note that this is periodic with period 4 (or 2 when ignoring global phase).
    @property
    def half_turns(self) -> global___ParameterizedFloat: ...
    def __init__(self,
        *,
        target : typing.Optional[global___Qubit] = ...,
        half_turns : typing.Optional[global___ParameterizedFloat] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"half_turns",b"half_turns",u"target",b"target"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"half_turns",b"half_turns",u"target",b"target"]) -> None: ...
global___ExpZ = ExpZ

# A two qubit rotation which acts to phase only the |11> state.
#
# This gate is exp(i * pi * H  * t) where H = |11><11| or in matrix form
#   H = diag(0, 0, 0, 1)
class Exp11(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TARGET1_FIELD_NUMBER: builtins.int
    TARGET2_FIELD_NUMBER: builtins.int
    HALF_TURNS_FIELD_NUMBER: builtins.int
    # The first qubit to interact.
    @property
    def target1(self) -> global___Qubit: ...
    # The other qubit to interact.
    @property
    def target2(self) -> global___Qubit: ...
    # The amount of the rotation in units of pi, i.e. the t in
    # exp(i * pi * |11><11| * t).
    # Note that this is periodic with period 2 (including global phase).
    @property
    def half_turns(self) -> global___ParameterizedFloat: ...
    def __init__(self,
        *,
        target1 : typing.Optional[global___Qubit] = ...,
        target2 : typing.Optional[global___Qubit] = ...,
        half_turns : typing.Optional[global___ParameterizedFloat] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"half_turns",b"half_turns",u"target1",b"target1",u"target2",b"target2"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"half_turns",b"half_turns",u"target1",b"target1",u"target2",b"target2"]) -> None: ...
global___Exp11 = Exp11

# A multi-qubit measurement in the computational basis (|0>, |1>).
class Measurement(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TARGETS_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    INVERT_MASK_FIELD_NUMBER: builtins.int
    # The qubits to measure.
    @property
    def targets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Qubit]: ...
    # The key that this measurement's bit will be grouped under.
    # Measurement keys must be unique across the circuit.
    key: typing.Text = ...
    # If not empty, a list of booleans describing whether the results should
    # be flipped for each of the qubits above. The length of this vector must
    # match the length of the qubits, and the interpretation of whether to
    # invert or not matches component-wise this list and the qubits' list.
    @property
    def invert_mask(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bool]: ...
    def __init__(self,
        *,
        targets : typing.Optional[typing.Iterable[global___Qubit]] = ...,
        key : typing.Text = ...,
        invert_mask : typing.Optional[typing.Iterable[builtins.bool]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"invert_mask",b"invert_mask",u"key",b"key",u"targets",b"targets"]) -> None: ...
global___Measurement = Measurement

# An operation to apply: either a gate or a measurement.
class Operation(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INCREMENTAL_DELAY_PICOSECONDS_FIELD_NUMBER: builtins.int
    EXP_W_FIELD_NUMBER: builtins.int
    EXP_Z_FIELD_NUMBER: builtins.int
    EXP_11_FIELD_NUMBER: builtins.int
    MEASUREMENT_FIELD_NUMBER: builtins.int
    # When this operation should be done, relative to the previous operation.
    # Use a delay of 0 to apply simultaneous with previous operation.
    # (Implies operations must be sorted by application order.)
    incremental_delay_picoseconds: builtins.int = ...
    # A single-qubit rotation around an axis on the XY equator.
    @property
    def exp_w(self) -> global___ExpW: ...
    # A single-qubit rotation around the Z axis.
    @property
    def exp_z(self) -> global___ExpZ: ...
    # An operation that interacts two qubits, phasing only the 11 state.
    @property
    def exp_11(self) -> global___Exp11: ...
    # Measures a qubit and indicates where to store the result.
    @property
    def measurement(self) -> global___Measurement: ...
    def __init__(self,
        *,
        incremental_delay_picoseconds : builtins.int = ...,
        exp_w : typing.Optional[global___ExpW] = ...,
        exp_z : typing.Optional[global___ExpZ] = ...,
        exp_11 : typing.Optional[global___Exp11] = ...,
        measurement : typing.Optional[global___Measurement] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"exp_11",b"exp_11",u"exp_w",b"exp_w",u"exp_z",b"exp_z",u"measurement",b"measurement",u"operation",b"operation"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"exp_11",b"exp_11",u"exp_w",b"exp_w",u"exp_z",b"exp_z",u"incremental_delay_picoseconds",b"incremental_delay_picoseconds",u"measurement",b"measurement",u"operation",b"operation"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"operation",b"operation"]) -> typing.Optional[typing_extensions.Literal["exp_w","exp_z","exp_11","measurement"]]: ...
global___Operation = Operation
