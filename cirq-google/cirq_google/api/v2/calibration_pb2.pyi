"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import cirq_google.api.v2.metrics_pb2
import cirq_google.api.v2.program_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class CalibrationLayerCode(_CalibrationLayerCode, metaclass=_CalibrationLayerCodeEnumTypeWrapper):
    """Response codes for Calibration requests"""
    pass
class _CalibrationLayerCode:
    V = typing.NewType('V', builtins.int)
class _CalibrationLayerCodeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_CalibrationLayerCode.V], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    CALIBRATION_RESULT_UNSPECIFIED = CalibrationLayerCode.V(0)
    """Zero is a default value and means the value was unknown or unset."""

    SUCCESS = CalibrationLayerCode.V(1)
    """Successful run of the calibration."""

    ERROR_OTHER = CalibrationLayerCode.V(2)
    """Miscellaenous errors not covered by the below conditions."""

    ERROR_INVALID_PARAMETERS = CalibrationLayerCode.V(3)
    """The parameters given to the calibration were not valid.
    For instance, multiple moments were given to a type of calibration
    that expects a single moment.
    """

    ERROR_TIMEOUT = CalibrationLayerCode.V(4)
    """The calibration took too long and was aborted."""

    ERROR_CALIBRATION_FAILED = CalibrationLayerCode.V(5)
    """The calibration failed for internal reasons.  For instance,
    suitable device parameters could not be acheived or dependencies
    needed by the calibration did not exist.
    """


CALIBRATION_RESULT_UNSPECIFIED = CalibrationLayerCode.V(0)
"""Zero is a default value and means the value was unknown or unset."""

SUCCESS = CalibrationLayerCode.V(1)
"""Successful run of the calibration."""

ERROR_OTHER = CalibrationLayerCode.V(2)
"""Miscellaenous errors not covered by the below conditions."""

ERROR_INVALID_PARAMETERS = CalibrationLayerCode.V(3)
"""The parameters given to the calibration were not valid.
For instance, multiple moments were given to a type of calibration
that expects a single moment.
"""

ERROR_TIMEOUT = CalibrationLayerCode.V(4)
"""The calibration took too long and was aborted."""

ERROR_CALIBRATION_FAILED = CalibrationLayerCode.V(5)
"""The calibration failed for internal reasons.  For instance,
suitable device parameters could not be acheived or dependencies
needed by the calibration did not exist.
"""

global___CalibrationLayerCode = CalibrationLayerCode


class FocusedCalibration(google.protobuf.message.Message):
    """ This message represents a request to execute a custom calibration routine."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    LAYERS_FIELD_NUMBER: builtins.int
    @property
    def layers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___CalibrationLayer]:
        """The layers field represents each invocation of a calibration
        procedure.

        For instance, each (unique) moment of a circuit could be
        calibrated using parallel_xeb.  In this case,
        each moment would have its own CalibrationLayer.

        Some calibrations, such as a readout calibration,
        will only have one layer.
        """
        pass
    def __init__(self,
        *,
        layers : typing.Optional[typing.Iterable[global___CalibrationLayer]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"layers",b"layers"]) -> None: ...
global___FocusedCalibration = FocusedCalibration

class CalibrationLayer(google.protobuf.message.Message):
    """Each CalibrationLayer represents one invocation
    of a calibration procedure.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ArgsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> cirq_google.api.v2.program_pb2.Arg: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[cirq_google.api.v2.program_pb2.Arg] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

    CALIBRATION_TYPE_FIELD_NUMBER: builtins.int
    LAYER_FIELD_NUMBER: builtins.int
    ARGS_FIELD_NUMBER: builtins.int
    calibration_type: typing.Text = ...
    """The type of the calibration procedure to execute.
    The value of this field must be in one of the acceptable
    values found in the cirq enum TBD.
    TODO(dstrain): Point to the cirq enum once it exists.
    """

    @property
    def layer(self) -> cirq_google.api.v2.program_pb2.Program:
        """A circuit that identifies the layer or circuit to optimize
        if the calibration requires this.  For many calibrations,
        this will be a single moment representing the layer to
        optimize for.
        """
        pass
    @property
    def args(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, cirq_google.api.v2.program_pb2.Arg]:
        """Arguments that can be specified to the calibration procedure,
        such as the number of layers, which angles to optimize, etc
        """
        pass
    def __init__(self,
        *,
        calibration_type : typing.Text = ...,
        layer : typing.Optional[cirq_google.api.v2.program_pb2.Program] = ...,
        args : typing.Optional[typing.Mapping[typing.Text, cirq_google.api.v2.program_pb2.Arg]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"layer",b"layer"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"args",b"args",u"calibration_type",b"calibration_type",u"layer",b"layer"]) -> None: ...
global___CalibrationLayer = CalibrationLayer

class FocusedCalibrationResult(google.protobuf.message.Message):
    """The results returned by a FocusedCalibration request."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RESULTS_FIELD_NUMBER: builtins.int
    @property
    def results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___CalibrationLayerResult]:
        """The results of each CalibrationLayer request.
        There will be one CalibrationLayerResults message for each
        CalibrationLayer in the request, and the results will
        correspond to the order of the requests.
        """
        pass
    def __init__(self,
        *,
        results : typing.Optional[typing.Iterable[global___CalibrationLayerResult]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"results",b"results"]) -> None: ...
global___FocusedCalibrationResult = FocusedCalibrationResult

class CalibrationLayerResult(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CODE_FIELD_NUMBER: builtins.int
    ERROR_MESSAGE_FIELD_NUMBER: builtins.int
    TOKEN_FIELD_NUMBER: builtins.int
    METRICS_FIELD_NUMBER: builtins.int
    VALID_UNTIL_MS_FIELD_NUMBER: builtins.int
    code: global___CalibrationLayerCode.V = ...
    """Whether the calibration procedure was a success or failure."""

    error_message: typing.Text = ...
    """On non-successful results, contains additional information
    about the details of the error.
    """

    token: typing.Text = ...
    """A token identifying the calibration result.
    If a token exists in the response, it can be used to tag
    focused circuits that use parameters
    derived from this calibration.
    If no token exists, then the calibration was purely diagnostic.
    """

    @property
    def metrics(self) -> cirq_google.api.v2.metrics_pb2.MetricsSnapshot:
        """Results, such as gate fidelities, gate angles, etc
        would be returned in a similar format to calibration metrics.
        This allows the return result to be easily extensible.
        """
        pass
    valid_until_ms: builtins.int = ...
    """Timestamp of when the calibration is valid until, specified as
    milliseconds since the Unix epoch time.
    """

    def __init__(self,
        *,
        code : global___CalibrationLayerCode.V = ...,
        error_message : typing.Text = ...,
        token : typing.Text = ...,
        metrics : typing.Optional[cirq_google.api.v2.metrics_pb2.MetricsSnapshot] = ...,
        valid_until_ms : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"metrics",b"metrics"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"code",b"code",u"error_message",b"error_message",u"metrics",b"metrics",u"token",b"token",u"valid_until_ms",b"valid_until_ms"]) -> None: ...
global___CalibrationLayerResult = CalibrationLayerResult
