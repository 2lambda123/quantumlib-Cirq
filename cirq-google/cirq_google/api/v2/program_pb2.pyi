"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

# A quantum program.
class Program(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    LANGUAGE_FIELD_NUMBER: builtins.int
    CIRCUIT_FIELD_NUMBER: builtins.int
    SCHEDULE_FIELD_NUMBER: builtins.int
    CONSTANTS_FIELD_NUMBER: builtins.int
    # The language in which the program is written.
    @property
    def language(self) -> global___Language: ...
    # A circuit is an abstract representation as a series of moments, each
    # moment having a set of gates that act on disjoint qubits. Circuits don't
    # have absolute times for their operations (gates acting on qubits).
    @property
    def circuit(self) -> global___Circuit: ...
    # Schedules are a list of operations (gates acting on qubits) that specify
    # absolute start times for the operations.
    @property
    def schedule(self) -> global___Schedule: ...
    # List to store global constants, such as strings used in many places.
    # constants are referred to their index in this list, starting at zero.
    @property
    def constants(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Constant]: ...
    def __init__(self,
        *,
        language : typing.Optional[global___Language] = ...,
        circuit : typing.Optional[global___Circuit] = ...,
        schedule : typing.Optional[global___Schedule] = ...,
        constants : typing.Optional[typing.Iterable[global___Constant]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"circuit",b"circuit",u"language",b"language",u"program",b"program",u"schedule",b"schedule"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"circuit",b"circuit",u"constants",b"constants",u"language",b"language",u"program",b"program",u"schedule",b"schedule"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"program",b"program"]) -> typing.Optional[typing_extensions.Literal["circuit","schedule"]]: ...
global___Program = Program

# Constants, such as long strings, that are used throughout the circuit.
# These constants can be stored here to save space.
class Constant(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    STRING_VALUE_FIELD_NUMBER: builtins.int
    CIRCUIT_VALUE_FIELD_NUMBER: builtins.int
    QUBIT_FIELD_NUMBER: builtins.int
    # String value used throughout the circuit, such as for token values
    string_value: typing.Text = ...
    # Sub Circuit used for CircuitOperations
    @property
    def circuit_value(self) -> global___Circuit: ...
    # Qubits used within the circuit (only populated in v2.5+)
    @property
    def qubit(self) -> global___Qubit: ...
    def __init__(self,
        *,
        string_value : typing.Text = ...,
        circuit_value : typing.Optional[global___Circuit] = ...,
        qubit : typing.Optional[global___Qubit] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"circuit_value",b"circuit_value",u"const_value",b"const_value",u"qubit",b"qubit",u"string_value",b"string_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"circuit_value",b"circuit_value",u"const_value",b"const_value",u"qubit",b"qubit",u"string_value",b"string_value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"const_value",b"const_value"]) -> typing.Optional[typing_extensions.Literal["string_value","circuit_value","qubit"]]: ...
global___Constant = Constant

# The quantum circuit, specified as a series of moments (abstract
# slices of times with gates acting on disjoint sets of qubits).
class Circuit(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    # How the circuit is scheduled.
    class SchedulingStrategy(_SchedulingStrategy, metaclass=_SchedulingStrategyEnumTypeWrapper):
        pass
    class _SchedulingStrategy:
        V = typing.NewType('V', builtins.int)
    class _SchedulingStrategyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SchedulingStrategy.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        # The scheduling strategy is unspecified.
        SCHEDULING_STRATEGY_UNSPECIFIED = Circuit.SchedulingStrategy.V(0)
        # Each operation in a moment starts at the same time. The start of the
        # next moment is given by the duration of the longest operation in
        # the current moment.
        MOMENT_BY_MOMENT = Circuit.SchedulingStrategy.V(1)

    # The scheduling strategy is unspecified.
    SCHEDULING_STRATEGY_UNSPECIFIED = Circuit.SchedulingStrategy.V(0)
    # Each operation in a moment starts at the same time. The start of the
    # next moment is given by the duration of the longest operation in
    # the current moment.
    MOMENT_BY_MOMENT = Circuit.SchedulingStrategy.V(1)

    SCHEDULING_STRATEGY_FIELD_NUMBER: builtins.int
    MOMENTS_FIELD_NUMBER: builtins.int
    scheduling_strategy: global___Circuit.SchedulingStrategy.V = ...
    # The moments of the circuit, with the first element corresponding to the
    # first set of operations to apply, etc.
    @property
    def moments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Moment]: ...
    def __init__(self,
        *,
        scheduling_strategy : global___Circuit.SchedulingStrategy.V = ...,
        moments : typing.Optional[typing.Iterable[global___Moment]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"moments",b"moments",u"scheduling_strategy",b"scheduling_strategy"]) -> None: ...
global___Circuit = Circuit

# A moment is a collection of operations and circuit operations that operate
# on a disjoint set of qubits. Conceptually, a moment represents operations
# that all occur in the same finite period of time.
class Moment(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    OPERATIONS_FIELD_NUMBER: builtins.int
    CIRCUIT_OPERATIONS_FIELD_NUMBER: builtins.int
    # All of the gate operations in the moment. Each operation and circuit
    # operation must act on different qubits.
    @property
    def operations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Operation]: ...
    # All of the circuit operations in the moment. Each operation and circuit
    # operation must act on different qubits.
    @property
    def circuit_operations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___CircuitOperation]: ...
    def __init__(self,
        *,
        operations : typing.Optional[typing.Iterable[global___Operation]] = ...,
        circuit_operations : typing.Optional[typing.Iterable[global___CircuitOperation]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"circuit_operations",b"circuit_operations",u"operations",b"operations"]) -> None: ...
global___Moment = Moment

# The quantum circuit, specified as a series of operations at specific
# start times.
class Schedule(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SCHEDULED_OPERATIONS_FIELD_NUMBER: builtins.int
    # A list of all the operations and their absolute start times.
    @property
    def scheduled_operations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ScheduledOperation]: ...
    def __init__(self,
        *,
        scheduled_operations : typing.Optional[typing.Iterable[global___ScheduledOperation]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"scheduled_operations",b"scheduled_operations"]) -> None: ...
global___Schedule = Schedule

# An operation occurring at a specific start time.
class ScheduledOperation(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    OPERATION_FIELD_NUMBER: builtins.int
    START_TIME_PICOS_FIELD_NUMBER: builtins.int
    # Which operation is to be scheduled.
    @property
    def operation(self) -> global___Operation: ...
    # The start time of the operation, with zero representing the absolute
    # start of the circuit.
    #
    # This must be consistent with the moment structure and must be positive.
    start_time_picos: builtins.int = ...
    def __init__(self,
        *,
        operation : typing.Optional[global___Operation] = ...,
        start_time_picos : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"operation",b"operation"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"operation",b"operation",u"start_time_picos",b"start_time_picos"]) -> None: ...
global___ScheduledOperation = ScheduledOperation

# The language in which the program is expressed.
class Language(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GATE_SET_FIELD_NUMBER: builtins.int
    ARG_FUNCTION_LANGUAGE_FIELD_NUMBER: builtins.int
    # The name of the gate set being used.
    #
    # Valid names for the gate sets can be found in cirq/google/gate_sets.py.
    gate_set: typing.Text = ...
    # The language supported by ArgFunctions. These specifies what allowed
    # ArgFunction types there are.
    #
    # Valid names for the arg function language can be found in
    # cirq/google/arg_func_langs.py
    arg_function_language: typing.Text = ...
    def __init__(self,
        *,
        gate_set : typing.Text = ...,
        arg_function_language : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"arg_function_language",b"arg_function_language",u"gate_set",b"gate_set"]) -> None: ...
global___Language = Language

# Argument that is constrained to a float or symbolic expression
class FloatArg(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FLOAT_VALUE_FIELD_NUMBER: builtins.int
    SYMBOL_FIELD_NUMBER: builtins.int
    FUNC_FIELD_NUMBER: builtins.int
    float_value: builtins.float = ...
    symbol: typing.Text = ...
    @property
    def func(self) -> global___ArgFunction: ...
    def __init__(self,
        *,
        float_value : builtins.float = ...,
        symbol : typing.Text = ...,
        func : typing.Optional[global___ArgFunction] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"arg",b"arg",u"float_value",b"float_value",u"func",b"func",u"symbol",b"symbol"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"arg",b"arg",u"float_value",b"float_value",u"func",b"func",u"symbol",b"symbol"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"arg",b"arg"]) -> typing.Optional[typing_extensions.Literal["float_value","symbol","func"]]: ...
global___FloatArg = FloatArg

# Representation of cirq.XPowGate
class XPowGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXPONENT_FIELD_NUMBER: builtins.int
    @property
    def exponent(self) -> global___FloatArg: ...
    def __init__(self,
        *,
        exponent : typing.Optional[global___FloatArg] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"exponent",b"exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"exponent",b"exponent"]) -> None: ...
global___XPowGate = XPowGate

# Representation of cirq.YPowGate
class YPowGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXPONENT_FIELD_NUMBER: builtins.int
    @property
    def exponent(self) -> global___FloatArg: ...
    def __init__(self,
        *,
        exponent : typing.Optional[global___FloatArg] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"exponent",b"exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"exponent",b"exponent"]) -> None: ...
global___YPowGate = YPowGate

# Representation of cirq.ZPowGate
class ZPowGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXPONENT_FIELD_NUMBER: builtins.int
    IS_PHYSICAL_Z_FIELD_NUMBER: builtins.int
    @property
    def exponent(self) -> global___FloatArg: ...
    # If true, this is equivalent to:
    # cirq.ZPowGate(...).with_tags(cirq.google.PhysicalZTag)
    is_physical_z: builtins.bool = ...
    def __init__(self,
        *,
        exponent : typing.Optional[global___FloatArg] = ...,
        is_physical_z : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"exponent",b"exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"exponent",b"exponent",u"is_physical_z",b"is_physical_z"]) -> None: ...
global___ZPowGate = ZPowGate

# Representation of cirq.PhasedXPowGate
class PhasedXPowGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PHASE_EXPONENT_FIELD_NUMBER: builtins.int
    EXPONENT_FIELD_NUMBER: builtins.int
    @property
    def phase_exponent(self) -> global___FloatArg: ...
    @property
    def exponent(self) -> global___FloatArg: ...
    def __init__(self,
        *,
        phase_exponent : typing.Optional[global___FloatArg] = ...,
        exponent : typing.Optional[global___FloatArg] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"exponent",b"exponent",u"phase_exponent",b"phase_exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"exponent",b"exponent",u"phase_exponent",b"phase_exponent"]) -> None: ...
global___PhasedXPowGate = PhasedXPowGate

# Representation of cirq.PhasedXZGate
class PhasedXZGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    X_EXPONENT_FIELD_NUMBER: builtins.int
    Z_EXPONENT_FIELD_NUMBER: builtins.int
    AXIS_PHASE_EXPONENT_FIELD_NUMBER: builtins.int
    @property
    def x_exponent(self) -> global___FloatArg: ...
    @property
    def z_exponent(self) -> global___FloatArg: ...
    @property
    def axis_phase_exponent(self) -> global___FloatArg: ...
    def __init__(self,
        *,
        x_exponent : typing.Optional[global___FloatArg] = ...,
        z_exponent : typing.Optional[global___FloatArg] = ...,
        axis_phase_exponent : typing.Optional[global___FloatArg] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"axis_phase_exponent",b"axis_phase_exponent",u"x_exponent",b"x_exponent",u"z_exponent",b"z_exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"axis_phase_exponent",b"axis_phase_exponent",u"x_exponent",b"x_exponent",u"z_exponent",b"z_exponent"]) -> None: ...
global___PhasedXZGate = PhasedXZGate

# Representation of cirq.CZPowGate
class CZPowGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXPONENT_FIELD_NUMBER: builtins.int
    @property
    def exponent(self) -> global___FloatArg: ...
    def __init__(self,
        *,
        exponent : typing.Optional[global___FloatArg] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"exponent",b"exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"exponent",b"exponent"]) -> None: ...
global___CZPowGate = CZPowGate

# Representation of cirq.FSimGate
class FSimGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    THETA_FIELD_NUMBER: builtins.int
    PHI_FIELD_NUMBER: builtins.int
    @property
    def theta(self) -> global___FloatArg: ...
    @property
    def phi(self) -> global___FloatArg: ...
    def __init__(self,
        *,
        theta : typing.Optional[global___FloatArg] = ...,
        phi : typing.Optional[global___FloatArg] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"phi",b"phi",u"theta",b"theta"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"phi",b"phi",u"theta",b"theta"]) -> None: ...
global___FSimGate = FSimGate

# Representation of cirq.ISwapPowGate
class ISwapPowGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXPONENT_FIELD_NUMBER: builtins.int
    @property
    def exponent(self) -> global___FloatArg: ...
    def __init__(self,
        *,
        exponent : typing.Optional[global___FloatArg] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"exponent",b"exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"exponent",b"exponent"]) -> None: ...
global___ISwapPowGate = ISwapPowGate

# Representation of cirq.MeasurementGate
# i.e. cirq.measure
class MeasurementGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    KEY_FIELD_NUMBER: builtins.int
    INVERT_MASK_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> global___Arg: ...
    @property
    def invert_mask(self) -> global___Arg: ...
    def __init__(self,
        *,
        key : typing.Optional[global___Arg] = ...,
        invert_mask : typing.Optional[global___Arg] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"invert_mask",b"invert_mask",u"key",b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"invert_mask",b"invert_mask",u"key",b"key"]) -> None: ...
global___MeasurementGate = MeasurementGate

# Representation of cirq.WAitGate
class WaitGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DURATION_NANOS_FIELD_NUMBER: builtins.int
    # Duration of the waiting period,
    # serialized to the number of nanoseconds
    @property
    def duration_nanos(self) -> global___FloatArg: ...
    def __init__(self,
        *,
        duration_nanos : typing.Optional[global___FloatArg] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"duration_nanos",b"duration_nanos"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"duration_nanos",b"duration_nanos"]) -> None: ...
global___WaitGate = WaitGate

# An operation acts on a set of qubits.
class Operation(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ArgsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> global___Arg: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[global___Arg] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

    GATE_FIELD_NUMBER: builtins.int
    XPOWGATE_FIELD_NUMBER: builtins.int
    YPOWGATE_FIELD_NUMBER: builtins.int
    ZPOWGATE_FIELD_NUMBER: builtins.int
    PHASEDXPOWGATE_FIELD_NUMBER: builtins.int
    PHASEDXZGATE_FIELD_NUMBER: builtins.int
    CZPOWGATE_FIELD_NUMBER: builtins.int
    FSIMGATE_FIELD_NUMBER: builtins.int
    ISWAPPOWGATE_FIELD_NUMBER: builtins.int
    MEASUREMENTGATE_FIELD_NUMBER: builtins.int
    WAITGATE_FIELD_NUMBER: builtins.int
    ARGS_FIELD_NUMBER: builtins.int
    QUBITS_FIELD_NUMBER: builtins.int
    QUBIT_CONSTANT_INDEX_FIELD_NUMBER: builtins.int
    TOKEN_VALUE_FIELD_NUMBER: builtins.int
    TOKEN_CONSTANT_INDEX_FIELD_NUMBER: builtins.int
    # Which gate this operation corresponds to.
    # Populated pre-v2.5+.
    @property
    def gate(self) -> global___Gate: ...
    @property
    def xpowgate(self) -> global___XPowGate: ...
    @property
    def ypowgate(self) -> global___YPowGate: ...
    @property
    def zpowgate(self) -> global___ZPowGate: ...
    @property
    def phasedxpowgate(self) -> global___PhasedXPowGate: ...
    @property
    def phasedxzgate(self) -> global___PhasedXZGate: ...
    @property
    def czpowgate(self) -> global___CZPowGate: ...
    @property
    def fsimgate(self) -> global___FSimGate: ...
    @property
    def iswappowgate(self) -> global___ISwapPowGate: ...
    @property
    def measurementgate(self) -> global___MeasurementGate: ...
    @property
    def waitgate(self) -> global___WaitGate: ...
    # Map from the argument name to the Argument needed to fully specify
    # the gate. Only populated pre-v2.5+.
    @property
    def args(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___Arg]: ...
    # Which qubits the operation acts on.
    # Operations should populate one of the following two
    # fields: either to specify the qubit directly or
    # to reference an index in the enclosing Program's
    # constant messages.  Note that qubit_constant_index
    # will only be populated in v2.5+
    @property
    def qubits(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Qubit]: ...
    @property
    def qubit_constant_index(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    token_value: typing.Text = ...
    token_constant_index: builtins.int = ...
    def __init__(self,
        *,
        gate : typing.Optional[global___Gate] = ...,
        xpowgate : typing.Optional[global___XPowGate] = ...,
        ypowgate : typing.Optional[global___YPowGate] = ...,
        zpowgate : typing.Optional[global___ZPowGate] = ...,
        phasedxpowgate : typing.Optional[global___PhasedXPowGate] = ...,
        phasedxzgate : typing.Optional[global___PhasedXZGate] = ...,
        czpowgate : typing.Optional[global___CZPowGate] = ...,
        fsimgate : typing.Optional[global___FSimGate] = ...,
        iswappowgate : typing.Optional[global___ISwapPowGate] = ...,
        measurementgate : typing.Optional[global___MeasurementGate] = ...,
        waitgate : typing.Optional[global___WaitGate] = ...,
        args : typing.Optional[typing.Mapping[typing.Text, global___Arg]] = ...,
        qubits : typing.Optional[typing.Iterable[global___Qubit]] = ...,
        qubit_constant_index : typing.Optional[typing.Iterable[builtins.int]] = ...,
        token_value : typing.Text = ...,
        token_constant_index : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"czpowgate",b"czpowgate",u"fsimgate",b"fsimgate",u"gate",b"gate",u"gate_value",b"gate_value",u"iswappowgate",b"iswappowgate",u"measurementgate",b"measurementgate",u"phasedxpowgate",b"phasedxpowgate",u"phasedxzgate",b"phasedxzgate",u"token",b"token",u"token_constant_index",b"token_constant_index",u"token_value",b"token_value",u"waitgate",b"waitgate",u"xpowgate",b"xpowgate",u"ypowgate",b"ypowgate",u"zpowgate",b"zpowgate"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"args",b"args",u"czpowgate",b"czpowgate",u"fsimgate",b"fsimgate",u"gate",b"gate",u"gate_value",b"gate_value",u"iswappowgate",b"iswappowgate",u"measurementgate",b"measurementgate",u"phasedxpowgate",b"phasedxpowgate",u"phasedxzgate",b"phasedxzgate",u"qubit_constant_index",b"qubit_constant_index",u"qubits",b"qubits",u"token",b"token",u"token_constant_index",b"token_constant_index",u"token_value",b"token_value",u"waitgate",b"waitgate",u"xpowgate",b"xpowgate",u"ypowgate",b"ypowgate",u"zpowgate",b"zpowgate"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"gate_value",b"gate_value"]) -> typing.Optional[typing_extensions.Literal["xpowgate","ypowgate","zpowgate","phasedxpowgate","phasedxzgate","czpowgate","fsimgate","iswappowgate","measurementgate","waitgate"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"token",b"token"]) -> typing.Optional[typing_extensions.Literal["token_value","token_constant_index"]]: ...
global___Operation = Operation

# The instruction identifying the action taken on the quantum computer.
class Gate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    # Name for the Gate.
    #
    # These names must match those specified in the gate set.  This is found
    # in cirq/google/gate_sets.py.
    id: typing.Text = ...
    def __init__(self,
        *,
        id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"id",b"id"]) -> None: ...
global___Gate = Gate

# An identifier for a qubit.
class Qubit(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    # Id of the qubit. These depend on the device being scheduled upon.
    #
    # Typically ids for qubits on a line are simple string versions of integers,
    # while for qubits on a square grid these are integers separated by a
    # underscore, i.e. '0_1', '1_2', etc.
    id: typing.Text = ...
    def __init__(self,
        *,
        id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"id",b"id"]) -> None: ...
global___Qubit = Qubit

# Arguments needed to specify a gate.
class Arg(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ARG_VALUE_FIELD_NUMBER: builtins.int
    SYMBOL_FIELD_NUMBER: builtins.int
    FUNC_FIELD_NUMBER: builtins.int
    CONSTANT_INDEX_FIELD_NUMBER: builtins.int
    @property
    def arg_value(self) -> global___ArgValue: ...
    symbol: typing.Text = ...
    @property
    def func(self) -> global___ArgFunction: ...
    constant_index: builtins.int = ...
    def __init__(self,
        *,
        arg_value : typing.Optional[global___ArgValue] = ...,
        symbol : typing.Text = ...,
        func : typing.Optional[global___ArgFunction] = ...,
        constant_index : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"arg",b"arg",u"arg_value",b"arg_value",u"constant_index",b"constant_index",u"func",b"func",u"symbol",b"symbol"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"arg",b"arg",u"arg_value",b"arg_value",u"constant_index",b"constant_index",u"func",b"func",u"symbol",b"symbol"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"arg",b"arg"]) -> typing.Optional[typing_extensions.Literal["arg_value","symbol","func","constant_index"]]: ...
global___Arg = Arg

# Value that can be passed as an argument to a gate.
class ArgValue(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FLOAT_VALUE_FIELD_NUMBER: builtins.int
    BOOL_VALUES_FIELD_NUMBER: builtins.int
    STRING_VALUE_FIELD_NUMBER: builtins.int
    DOUBLE_VALUE_FIELD_NUMBER: builtins.int
    float_value: builtins.float = ...
    @property
    def bool_values(self) -> global___RepeatedBoolean: ...
    string_value: typing.Text = ...
    double_value: builtins.float = ...
    def __init__(self,
        *,
        float_value : builtins.float = ...,
        bool_values : typing.Optional[global___RepeatedBoolean] = ...,
        string_value : typing.Text = ...,
        double_value : builtins.float = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"arg_value",b"arg_value",u"bool_values",b"bool_values",u"double_value",b"double_value",u"float_value",b"float_value",u"string_value",b"string_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"arg_value",b"arg_value",u"bool_values",b"bool_values",u"double_value",b"double_value",u"float_value",b"float_value",u"string_value",b"string_value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"arg_value",b"arg_value"]) -> typing.Optional[typing_extensions.Literal["float_value","bool_values","string_value","double_value"]]: ...
global___ArgValue = ArgValue

# A repeated boolean value.
class RepeatedBoolean(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bool]: ...
    def __init__(self,
        *,
        values : typing.Optional[typing.Iterable[builtins.bool]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"values",b"values"]) -> None: ...
global___RepeatedBoolean = RepeatedBoolean

# A function of arguments. This is an s-expression tree representing
# mathematically the function being evaluated.
#
# What language is supported is specified by the arg_function_language
# in the language message.
class ArgFunction(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TYPE_FIELD_NUMBER: builtins.int
    ARGS_FIELD_NUMBER: builtins.int
    # The name of the function. I.e. if the function is the sum of two symbols,
    # this could be '+', and the args would be two string symbol values.
    #
    # Valid values for the type are given in cirq/google/arg_func_langs.py
    # and must be consistent with the arg_function_language specified in the
    # language field of the program.
    type: typing.Text = ...
    # The arguments to the function.
    @property
    def args(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Arg]: ...
    def __init__(self,
        *,
        type : typing.Text = ...,
        args : typing.Optional[typing.Iterable[global___Arg]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"args",b"args",u"type",b"type"]) -> None: ...
global___ArgFunction = ArgFunction

# An operation that applies a modified version of a reference circuit. The
# circuit is stored in the top-level Constants table; the mappings in this
# object specify how that circuit should be modified for this operation.
#
# Multiple CircuitOperations may reference the same base circuit even if their
# mappings of that circuit are different.
class CircuitOperation(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CIRCUIT_CONSTANT_INDEX_FIELD_NUMBER: builtins.int
    REPETITION_SPECIFICATION_FIELD_NUMBER: builtins.int
    QUBIT_MAP_FIELD_NUMBER: builtins.int
    MEASUREMENT_KEY_MAP_FIELD_NUMBER: builtins.int
    ARG_MAP_FIELD_NUMBER: builtins.int
    # The index of the circuit in the top-level constant table.
    circuit_constant_index: builtins.int = ...
    # Specifier for repetitions of the circuit, which contains either a number
    # of repetitions or a list of repetition IDs.
    @property
    def repetition_specification(self) -> global___RepetitionSpecification: ...
    # Map from qubits in the "inner" circuit (referenced by
    # circuit_constant_index) to qubits in the "outer" circuit (the one that
    # contains this operation).
    @property
    def qubit_map(self) -> global___QubitMapping: ...
    # Map of measurement keys in the "inner" circuit (referenced by
    # circuit_constant_index) to measurement keys in the "outer" circuit (the
    # one that contains this operation).
    @property
    def measurement_key_map(self) -> global___MeasurementKeyMapping: ...
    # Map of args in the "inner" circuit (referenced by circuit_constant_index)
    # to args in the "outer" circuit (the one that contains this operation).
    @property
    def arg_map(self) -> global___ArgMapping: ...
    def __init__(self,
        *,
        circuit_constant_index : builtins.int = ...,
        repetition_specification : typing.Optional[global___RepetitionSpecification] = ...,
        qubit_map : typing.Optional[global___QubitMapping] = ...,
        measurement_key_map : typing.Optional[global___MeasurementKeyMapping] = ...,
        arg_map : typing.Optional[global___ArgMapping] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"arg_map",b"arg_map",u"measurement_key_map",b"measurement_key_map",u"qubit_map",b"qubit_map",u"repetition_specification",b"repetition_specification"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"arg_map",b"arg_map",u"circuit_constant_index",b"circuit_constant_index",u"measurement_key_map",b"measurement_key_map",u"qubit_map",b"qubit_map",u"repetition_specification",b"repetition_specification"]) -> None: ...
global___CircuitOperation = CircuitOperation

# A description of the repetitions of a subcircuit. IDs are used as suffixes
# for measurements in the repeated subcircuit; if repetition_count is given
# instead, the IDs will simply be the integers [0..N-1].
class RepetitionSpecification(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    # An ordered list of IDs for a sequence of repetitions.
    class RepetitionIds(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        IDS_FIELD_NUMBER: builtins.int
        @property
        def ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
        def __init__(self,
            *,
            ids : typing.Optional[typing.Iterable[typing.Text]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"ids",b"ids"]) -> None: ...

    REPETITION_IDS_FIELD_NUMBER: builtins.int
    REPETITION_COUNT_FIELD_NUMBER: builtins.int
    # A list of unique IDs, one per repetition of the subcircuit.
    @property
    def repetition_ids(self) -> global___RepetitionSpecification.RepetitionIds: ...
    # An integer number of repetitions to perform.
    repetition_count: builtins.int = ...
    def __init__(self,
        *,
        repetition_ids : typing.Optional[global___RepetitionSpecification.RepetitionIds] = ...,
        repetition_count : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"repetition_count",b"repetition_count",u"repetition_ids",b"repetition_ids",u"repetition_value",b"repetition_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"repetition_count",b"repetition_count",u"repetition_ids",b"repetition_ids",u"repetition_value",b"repetition_value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"repetition_value",b"repetition_value"]) -> typing.Optional[typing_extensions.Literal["repetition_ids","repetition_count"]]: ...
global___RepetitionSpecification = RepetitionSpecification

# A mapping of qubits from one value to another. All mappings are applied
# simultaneously and independently; for example, [(a, b), (b, a)] will swap
# qubits a and b.
class QubitMapping(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    # Indicates that qubit "key" should be replaced with "value".
    class QubitEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        @property
        def key(self) -> global___Qubit: ...
        @property
        def value(self) -> global___Qubit: ...
        def __init__(self,
            *,
            key : typing.Optional[global___Qubit] = ...,
            value : typing.Optional[global___Qubit] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

    ENTRIES_FIELD_NUMBER: builtins.int
    # A list of qubit mappings to apply.
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___QubitMapping.QubitEntry]: ...
    def __init__(self,
        *,
        entries : typing.Optional[typing.Iterable[global___QubitMapping.QubitEntry]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"entries",b"entries"]) -> None: ...
global___QubitMapping = QubitMapping

# A key for matching a measurement event to its results.
class MeasurementKey(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    STRING_KEY_FIELD_NUMBER: builtins.int
    string_key: typing.Text = ...
    def __init__(self,
        *,
        string_key : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"string_key",b"string_key"]) -> None: ...
global___MeasurementKey = MeasurementKey

# A mapping of measurement keys from one value to another. All mappings are
# applied simultaneously and independently; for example, [(a, b), (b, a)] will
# swap measurement keys a and b.
class MeasurementKeyMapping(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    # Indicates that measurement key "key" should be replaced with "value".
    class MeasurementKeyEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        @property
        def key(self) -> global___MeasurementKey: ...
        @property
        def value(self) -> global___MeasurementKey: ...
        def __init__(self,
            *,
            key : typing.Optional[global___MeasurementKey] = ...,
            value : typing.Optional[global___MeasurementKey] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

    ENTRIES_FIELD_NUMBER: builtins.int
    # A list of measurement key mappings to apply.
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MeasurementKeyMapping.MeasurementKeyEntry]: ...
    def __init__(self,
        *,
        entries : typing.Optional[typing.Iterable[global___MeasurementKeyMapping.MeasurementKeyEntry]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"entries",b"entries"]) -> None: ...
global___MeasurementKeyMapping = MeasurementKeyMapping

# A mapping of args from one value to another. All mappings are applied
# simultaneously and independently; for example, [(a, b), (b, a)] will swap
# args a and b.
class ArgMapping(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    # Indicates that arg "key" should be replaced with "value".
    class ArgEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        @property
        def key(self) -> global___Arg: ...
        @property
        def value(self) -> global___Arg: ...
        def __init__(self,
            *,
            key : typing.Optional[global___Arg] = ...,
            value : typing.Optional[global___Arg] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

    ENTRIES_FIELD_NUMBER: builtins.int
    # A list of arg mappings to apply.
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ArgMapping.ArgEntry]: ...
    def __init__(self,
        *,
        entries : typing.Optional[typing.Iterable[global___ArgMapping.ArgEntry]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"entries",b"entries"]) -> None: ...
global___ArgMapping = ArgMapping
