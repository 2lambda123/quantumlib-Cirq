[1mdiff --git a/cirq/sim/sparse_simulator.py b/cirq/sim/sparse_simulator.py[m
[1mindex 26e8e171..54c15481 100644[m
[1m--- a/cirq/sim/sparse_simulator.py[m
[1m+++ b/cirq/sim/sparse_simulator.py[m
[36m@@ -98,7 +98,7 @@[m [mclass SparseState(AbstractState[act_on_state_vector_args.ActOnStateVectorArgs, '[m
 [m
 [m
 class Simulator([m
[31m-    simulator.SimulatesSamples, state_vector_simulator.SimulatesIntermediateStateVector[m
[32m+[m[32m    Generic[TState, TResult], simulator.SimulatesSamples, state_vector_simulator.SimulatesIntermediateStateVector[m
 ):[m
     """A sparse matrix state vector simulator that uses numpy.[m
 [m
[36m@@ -182,7 +182,7 @@[m [mclass Simulator([m
         *,[m
         dtype: Type[np.number] = np.complex64,[m
         seed: 'cirq.RANDOM_STATE_OR_SEED_LIKE' = None,[m
[31m-        state_algo: AbstractState = None,[m
[32m+[m[32m        state_algo: AbstractState[TState, TResult] = None,[m
     ):[m
         """A sparse matrix simulator.[m
 [m
[36m@@ -262,7 +262,7 @@[m [mclass Simulator([m
         qubit_order: ops.QubitOrderOrList,[m
         initial_state: 'cirq.STATE_VECTOR_LIKE',[m
         perform_measurements: bool = True,[m
[31m-    ) -> Iterator['SparseSimulatorStep']:[m
[32m+[m[32m    ) -> Iterator[TResult]:[m
         qubits = ops.QubitOrder.as_qubit_order(qubit_order).order_for(circuit.all_qubits())[m
         sim_state = self.state_algo.create_sim_state(initial_state, qubits)[m
         qubit_map = {q: i for i, q in enumerate(qubits)}[m
