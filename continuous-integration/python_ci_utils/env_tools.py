import subprocess
import sys
from typing import List, Optional, Callable, TypeVar

import os
import requests
import shutil
import tempfile

BOLD = 1
DIM = 2
RED = 31
GREEN = 32
YELLOW = 33
TResult = TypeVar('TResult')


def highlight(text: str, color_code: int, bold: bool=False) -> str:
    """Wraps the given string with terminal color codes.

    Args:
        text: The content to highlight.
        color_code: The color to highlight with, e.g. 'shelltools.RED'.
        bold: Whether to bold the content in addition to coloring.

    Returns:
        The highlighted string.
    """
    return '{}\033[{}m{}\033[0m'.format(
        '\033[1m' if bold else '',
        color_code,
        text,)


def run(*cmd, **kwargs) -> str:
    """Run a shell command and return the output as a string."""
    print('run', cmd, kwargs, file=sys.stderr)
    output = subprocess.check_output(cmd, **kwargs)
    if not isinstance(output, str):
        output = output.decode()
    return output.strip()


def run_with_stdout_into_stderr(*cmd, **kwargs) -> subprocess.CompletedProcess:
    """Run a shell command and forward all its outputs into stderr."""
    print('run', cmd, kwargs, file=sys.stderr)
    return subprocess.run(cmd,
                          **kwargs,
                          stdout=sys.stderr,
                          stderr=sys.stderr)


def run_forward_into_std(*cmd, **kwargs) -> subprocess.CompletedProcess:
    """Run a shell command and forward its outputs into stdout/stderr."""
    print('run', cmd, kwargs, file=sys.stderr)
    return subprocess.run(cmd,
                          **kwargs,
                          stdout=sys.stdout,
                          stderr=sys.stderr)


def run_lines(*cmd, **kwargs) -> List[str]:
    """Run a shell command and return output lines as a list of strings."""
    output = run(*cmd, **kwargs)
    lines = output.split('\n')
    # Output typically has a final newline on the last line; split turns this
    # into a spurious trailing empty line, which we strip off.
    if len(lines) > 1 and not lines[-1]:
        lines = lines[:-1]
    return lines


def py_files(files: List[str]) -> List[str]:
    """Filter a list of filenames to include non-autogenerated python files."""
    return [f
            for f in files
            if f.endswith('.py') and not f.endswith('_pb2.py')]


def get_repo_root() -> str:
    """Get the root of the current git repository."""
    return run('git', 'rev-parse', '--show-toplevel')


def get_changed_files_between(
        base_commit: str,
        updated_commit: str='HEAD',
        git_root: str=None) -> List[str]:
    """Get the files changed on one git branch, since diverging from another.

    Args:
        base_commit: The id of the old commit to compare against.
        updated_commit: The id of the new commit with changes to find.
        git_root: Absolute path to the git repository root. If not specified,
            the git repository at or above the current working directory is
            used.

    Returns:
        List[str]: File paths of changed files, relative to the git repo root.
    """
    return run_lines(
        'git',
        'diff',
        '--name-only',
        base_commit,
        updated_commit,
        cwd=git_root)


def github_set_status_indicator(repository_organization: str,
                                repository_name: str,
                                repository_access_token: str,
                                commit_id: str,
                                state: str,
                                description: str,
                                context: str,
                                target_url: Optional[str] = None) -> None:
    """Sets a commit status indicator on github.

    Args:
        repository_organization: The github organization or account that the
            repository that the commit lives under.
        repository_name: The name of the github repository (not including
            the account name) that the commit lives under.
        repository_access_token: An access token generated by a github account
            with permission to update commit statuses on the target repository.
        commit_id: A hash that identities the commit to set a status on.
        state: The state of the status indicator. Must be 'error', 'failure',
            'pending', or 'success'.
        description: A summary of why the state is what it is,
            e.g. '5 lint errors' or 'tests passed!'.
        context: The name of the status indicator, e.g. 'pytest' or 'coverage'.
        target_url: Optional location where additional details about the status
            can be found, e.g. an online test results page.

    Raises:
        ValueError: Not one of the allowed states.
        IOError: The HTTP post request failed, or the response didn't have a
            201 code indicating success in the expected way.
    """
    if state not in ['error', 'failure', 'pending', 'success']:
        raise ValueError('Unrecognized state: {!r}'.format(state))

    payload = {
        'state': state,
        'description': description,
        'context': context,
    }
    if target_url is not None:
        payload['target_url'] = target_url

    url = ("https://api.github.com/repos/{}/{}/statuses/{}?access_token={}"
           .format(repository_organization,
                   repository_name,
                   commit_id,
                   repository_access_token))

    response = requests.post(url, json=payload)

    if response.status_code != 201:
        raise IOError('Request failed. Code: {}. Content: {}.'.format(
            response.status_code, response.content))


class GithubRepository:
    def __init__(self,
                 organization: str,
                 name: str,
                 access_token: Optional[str]):
        self.organization = organization
        self.name = name
        self.access_token = access_token

    def as_remote(self) -> str:
        return 'git@github.com:{}/{}.git'.format(self.organization,
                                                 self.name)


class PreparedEnv:
    def __init__(self,
                 repository: Optional[GithubRepository],
                 actual_commit_id: str,
                 compare_commit_id: str,
                 destination_directory: Optional[str],
                 virtual_env_path: Optional[str]):
        self.repository = repository
        self.actual_commit_id = actual_commit_id
        self.compare_commit_id = compare_commit_id
        if self.compare_commit_id == self.actual_commit_id:
            self.compare_commit_id += '~1'

        self.destination_directory = destination_directory
        self.virtual_env_path = virtual_env_path

    def report_status(self,
                      state: str,
                      description: str,
                      context: str,
                      target_url: Optional[str] = None):
        """Sets a commit status indicator on github, if running from a PR.

        If not running from a PR (i.e. repository is None), then just prints
        to stderr.

        Args:
            state: The state of the status indicator.
                Must be 'error', 'failure', 'pending', or 'success'.
            description: A summary of why the state is what it is,
                e.g. '5 lint errors' or 'tests passed!'.
            context: The name of the status indicator, e.g. 'pytest' or 'lint'.
            target_url: Optional location where additional details about the
                status can be found, e.g. an online test results page.

        Raises:
            ValueError: Not one of the allowed states.
            IOError: The HTTP post request failed, or the response didn't have
                a 201 code indicating success in the expected way.
        """

        print(repr(('report_status',
                    context,
                    state,
                    description,
                    target_url)), file=sys.stderr)

        if (self.repository is not None and
                self.repository.access_token is not None):
            github_set_status_indicator(
                repository_organization=self.repository.organization,
                repository_name=self.repository.name,
                repository_access_token=self.repository.access_token,
                commit_id=self.actual_commit_id,
                state=state,
                description=description,
                context=context,
                target_url=target_url)
        else:
            print('(no access token; skipped reporting status to github)',
                  file=sys.stderr)


def git_fetch_for_comparison(remote: str,
                             actual_branch: str,
                             compare_branch: str) -> PreparedEnv:
    """Fetches two branches including their common ancestor.

    Limits the depth of the fetch to avoid unnecessary work. Scales up the
    depth exponentially and tries again when the initial guess is not deep
    enough.

    Args:
        remote: The location of the remote repository, in a format that the
            git command will understand.
        actual_branch: A remote branch or ref to fetch,
        compare_branch: Another remote branch or ref to fetch,

    Returns:
        A ComparableCommits containing the commit id of the actual branch and
        a the id of a commit to compare against (e.g. for when doing incremental
        checks).
    """
    actual_id = None
    base_id = None
    for depth in [10, 100, 1000, None]:
        depth = '' if depth is None else '--depth={}'.format(depth)

        run('git', 'fetch', remote, actual_branch, depth)
        actual_id = run('git', 'rev-parse', 'FETCH_HEAD')

        run('git', 'fetch', remote, compare_branch, depth)
        base_id = run('git', 'rev-parse', 'FETCH_HEAD')

        try:
            common_ancestor_id = run('git', 'merge-base', actual_id, base_id)
            return PreparedEnv(None, actual_id, common_ancestor_id, None, None)
        except subprocess.CalledProcessError:
            # No common ancestor. We need to dig deeper.
            pass

    return PreparedEnv(None, actual_id, base_id, None, None)


def fetch_github_pull_request(destination_directory: str,
                              repository: GithubRepository,
                              pull_request_number: int) -> PreparedEnv:
    """Uses content from github to create a dir for testing and comparisons.

    Args:
        destination_directory: The location to fetch the contents into.
        repository: The github repository that the commit lives under.
        pull_request_number: The id of the pull request to clone. If None, then
            the master branch is cloned instead.

    Returns:
        Commit ids corresponding to content to test/compare.
    """

    branch = 'pull/{}/head'.format(pull_request_number)
    os.chdir(destination_directory)
    print('chdir', destination_directory, file=sys.stderr)

    run('git', 'init')
    result = git_fetch_for_comparison(remote=repository.as_remote(),
                                      actual_branch=branch,
                                      compare_branch='master')
    run('git', 'branch', 'compare_commit', result.compare_commit_id)
    run('git', 'checkout', '-b', 'actual_commit', result.actual_commit_id)
    return PreparedEnv(repository=repository,
                       actual_commit_id=result.actual_commit_id,
                       compare_commit_id=result.compare_commit_id,
                       destination_directory=destination_directory,
                       virtual_env_path=None)


def fetch_local_files(destination_directory: str) -> PreparedEnv:
    """Uses local files to create a directory for testing and comparisons.

    Args:
        destination_directory: The directory where the copied files should go.

    Returns:
        Commit ids corresponding to content to test/compare.
    """
    shutil.rmtree(destination_directory)
    shutil.copytree(get_repo_root(), destination_directory)
    os.chdir(destination_directory)
    print('chdir', destination_directory, file=sys.stderr)

    run('git', 'commit', '-a', '-m', 'working changes', '--allow-empty')
    run('find',
        '|', 'grep', '\\.pyc$',
        '|', 'xargs', 'rm', '-f',
        shell=True)
    run('find',
        '|', 'grep', '__pycache__',
        '|', 'xargs', 'rmdir', '-f',
        shell=True)
    commit_id = run('git', 'rev-parse', 'HEAD')
    compare_id = run('git', 'merge-base', commit_id, 'master')
    return PreparedEnv(repository=None,
                       actual_commit_id=commit_id,
                       compare_commit_id=compare_id,
                       destination_directory=destination_directory,
                       virtual_env_path=None)


def prepare_temporary_test_environment(
        destination_directory: str,
        repository: GithubRepository,
        pull_request_number: Optional[int],
        env_name: str = 'test_virtualenv',
        python_path: str = "/usr/bin/python3.5") -> PreparedEnv:
    """Prepares a temporary test environment at the (existing empty) directory.

    Args:
        destination_directory: The location to put files. The caller is
            responsible for deleting the directory, whether or not this method
             succeeds or fails.
        repository: The github repository to download content from, if a pull
            request number is given.
        pull_request_number: If set, test content is fetched from github.
            Otherwise copies of local files are used.
        env_name: The name to use for the virtual environment.
        python_path: Location of the python binary to use within the
            virtual environment.

    Returns:
        Commit ids corresponding to content to test/compare.
    """
    # Fetch content.
    if pull_request_number is not None:
        commit_ids = fetch_github_pull_request(
            destination_directory=destination_directory,
            repository=repository,
            pull_request_number=pull_request_number)
    else:
        commit_ids = fetch_local_files(
            destination_directory=destination_directory)

    # Create virtual environment.
    env_path = os.path.join(destination_directory, env_name)
    run_with_stdout_into_stderr('virtualenv', '-p', python_path, env_path)

    pip_path = os.path.join(env_path, 'bin', 'pip')
    run_with_stdout_into_stderr(pip_path, 'install', '-r', 'requirements.txt')

    return PreparedEnv(repository,
                       commit_ids.actual_commit_id,
                       commit_ids.compare_commit_id,
                       destination_directory,
                       env_path)
#
#
# def do_in_temporary_test_environment(
#         test_method: Callable[[str, str, str], TResult],
#         repository_organization: str,
#         repository_name: str,
#         pull_request_number: Optional[int] = None) -> TResult:
#     """Prepares a temporary test environment and invokes a method within it.
#
#     Args:
#         test_method: The method to invoke while the environment is ready.
#         repository_organization: The github organization of the repository
#             to download content from, if a pull request number is given.
#         repository_name: The name of the github repository
#             to download content from, if a pull request number is given.
#         pull_request_number: If set, test content is fetched from github.
#             Otherwise copies of local files are used.
#
#     Returns:
#         Whatever the test_method returned.
#     """
#     test_dir = tempfile.mkdtemp(prefix='test-{}-'.format(repository_name))
#
#     try:
#         commit_ids = prepare_temporary_test_environment(
#             destination_directory=test_dir,
#             repository_organization=repository_organization,
#             repository_name=repository_name,
#             pull_request_number=pull_request_number)
#
#         return test_method(
#             test_dir,
#             commit_ids.actual_commit_id,
#             commit_ids.compare_commit_id)
#     finally:
#         shutil.rmtree(test_dir)
