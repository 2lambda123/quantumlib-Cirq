import subprocess
import sys
from typing import List, Tuple, Optional, Callable, TypeVar

import os
import requests
import shutil
import tempfile

BOLD = 1
DIM = 2
RED = 31
GREEN = 32
YELLOW = 33


def highlight(text: str, color_code: int, bold: bool=False) -> str:
    """Wraps the given string with terminal color codes.

    Args:
        text: The content to highlight.
        color_code: The color to highlight with, e.g. 'shelltools.RED'.
        bold: Whether to bold the content in addition to coloring.

    Returns:
        The highlighted string.
    """
    return '{}\033[{}m{}\033[0m'.format(
        '\033[1m' if bold else '',
        color_code,
        text,)


def run(*cmd, **kwargs) -> str:
    """Run a shell command and return the output as a string."""
    output = subprocess.check_output(cmd, **kwargs)
    if not isinstance(output, str):
        output = output.decode()
    return output.strip()


def run_forward_into_std(*cmd, **kwargs) -> subprocess.CompletedProcess:
    """Run a shell command and forward its outputs into stdout/stderr."""
    return subprocess.run(cmd,
                          **kwargs,
                          stdout=sys.stdout,
                          stderr=sys.stderr)


def run_lines(*cmd, **kwargs) -> List[str]:
    """Run a shell command and return output lines as a list of strings."""
    output = run(*cmd, **kwargs)
    lines = output.split('\n')
    # Output typically has a final newline on the last line; split turns this
    # into a spurious trailing empty line, which we strip off.
    if len(lines) > 1 and not lines[-1]:
        lines = lines[:-1]
    return lines


def py_files(files: List[str]) -> List[str]:
    """Filter a list of filenames to include non-autogenerated python files."""
    return [f for f in files if f.endswith('.py') and not f.endswith('_pb2.py')]


def get_repo_root() -> str:
    """Get the root of the current git repository."""
    return run('git', 'rev-parse', '--show-toplevel')


def get_changed_files_vs_master(root: str=None) -> List[str]:
    """Get a list of python files changed on this branch compared to master.

    If we are currently on master, will get changes from the previous commit,
    i.e. master~1. The returned filenames will be relative to the root of the
    git repo.
    """
    current_commit = run('git', 'rev-parse', cwd=root)
    base_commit = run('git', 'merge-base', 'HEAD', 'origin/master', cwd=root)
    if base_commit == current_commit:
        base_commit = 'HEAD~1'
    return get_changed_files_between(base_commit)


def get_changed_files_between(
        base_commit: str,
        updated_commit: str='HEAD',
        git_root: str=None) -> List[str]:
    """Get the files changed on one git branch, since diverging from another.

    Args:
        base_commit: The id of the old commit to compare against.
        updated_commit: The id of the new commit with changes to find.
        git_root: Absolute path to the git repository root. If not specified,
            the git repository at or above the current working directory is
            used.

    Returns:
        List[str]: File paths of changed files, relative to the git repo root.
    """
    return run_lines(
        'git',
        'diff',
        '--name-only',
        base_commit,
        updated_commit,
        cwd=git_root)


def get_commits_to_compare() -> Tuple[str, str]:
    """
    Figures out what the 'current' commit is, and which commit to compare it
    to when doing incremental checks.

    Returns:
        Tuple[str, str]:
            Actual commit id and base commit id.
    """
    actual_commit = run('git', 'rev-parse', 'HEAD')

    base_commit = run(
        'git',
        'merge-base',
        actual_commit,
        'origin/master', )

    if base_commit == actual_commit:
        base_commit += '~1'

    return base_commit, actual_commit


def github_set_status_indicator(repository_organization: str,
                                repository_name: str,
                                repository_access_token: str,
                                commit_id: str,
                                state: str,
                                description: str,
                                context: str,
                                target_url: Optional[str] = None) -> None:
    """Sets a commit status indicator on github.

    Args:
        repository_organization: The github organization or account that the
            repository that the commit lives under.
        repository_name: The name of the github repository (not including
            the account name) that the commit lives under.
        repository_access_token: An access token generated by a github account
            with permission to update commit statuses on the target repository.
        commit_id: A hash that identities the commit to set a status on.
        state: The state of the status indicator. Must be 'error', 'failure',
            'pending', or 'success'.
        description: A summary of why the state is what it is,
            e.g. '5 lint errors' or 'tests passed!'.
        context: The name of the status indicator, e.g. 'pytest' or 'coverage'.
        target_url: Optional location where additional details about the status
            can be found, e.g. an online test results page.

    Raises:
        ValueError: Not one of the allowed states.
        IOError: The HTTP post request failed, or the response didn't have a
            201 code indicating success in the expected way.
    """
    if state not in ['error', 'failure', 'pending', 'success']:
        raise ValueError('Unrecognized state: {!r}'.format(state))

    payload = {
        'state': state,
        'description': description,
        'context': context,
    }
    if target_url is not None:
        payload['target_url'] = target_url

    url = ("https://api.github.com/repos/{}/{}/statuses/{}?access_token={}"
           .format(repository_organization,
                   repository_name,
                   commit_id,
                   repository_access_token))

    response = requests.post(url, json=payload)

    if response.status_code != 201:
        raise IOError('Request failed. Code: {}. Content: {}.'.format(
            response.status_code, response.content))


def github_fetch(destination_directory: str,
                 repository_organization: str,
                 repository_name: str,
                 also_fetch_master: bool,
                 pull_request_number: Optional[int] = None
                 ) -> Tuple[str, Optional[str]]:
    """Fetches a repository's contents from github.

    Args:
        destination_directory: The location to fetch the contents into.
        repository_organization: The github organization or account that the
            repository that the commit lives under.
        repository_name: The name of the github repository (not including
            the account name) that the commit lives under.
        also_fetch_master: Whether to also fetch the master branch.
        pull_request_number: The id of the pull request to clone. If None, then
            the master branch is cloned instead.
    """

    branch = ('master'
              if pull_request_number is None
              else 'pull/{}/head'.format(pull_request_number))
    remote = 'git@github.com:{}/{}.git'.format(repository_organization,
                                               repository_name)
    os.chdir(destination_directory)
    run('git', 'init', '--quiet')
    # TODO: handle case where master is ahead of merge-base.
    if also_fetch_master:
        run('git', 'fetch', remote, 'master', '--depth=1', '--quiet')
        run('git', 'branch', 'master', 'FETCH_HEAD')
        master_id = run('git', 'rev-parse', 'FETCH_HEAD')
    else:
        master_id = None
    run('git', 'fetch', remote, branch, '--depth=1', '--quiet')
    commit_id = run('git', 'rev-parse', 'FETCH_HEAD')
    run('git', 'checkout', commit_id, '--quiet')
    return commit_id, master_id


TResult = TypeVar('TResult')


def do_in_temporary_test_environment(
        test_method: Callable[[str, str, str], TResult],
        repository_organization: str,
        repository_name: str,
        pull_request_number: Optional[int] = None) -> TResult:
    test_dir = tempfile.mkdtemp(prefix='test-{}-'.format(repository_name))
    try:
        if pull_request_number is not None:
            # Use files from pull request.
            commit_id, compare_id = github_fetch(
                destination_directory=test_dir,
                repository_organization=repository_organization,
                repository_name=repository_name,
                pull_request_number=pull_request_number,
                also_fetch_master=True)
        else:
            # Use local files.
            shutil.rmtree(test_dir)
            shutil.copytree(get_repo_root(), test_dir)
            os.chdir(test_dir)
            run('git', 'commit', '-a', '-m', 'testing')
            run('find', '|', 'grep', '\\.pyc$', '|', 'xargs', 'rm', '-f', shell=True)
            run('find', '|', 'grep', '__pycache__', '|', 'xargs', 'rmdir', '-f', shell=True)
            commit_id = run('git', 'rev-parse', 'HEAD')
            compare_id = run('git', 'merge-base', commit_id, 'origin/master')
            if commit_id == compare_id:
                compare_id += '~1'

        return test_method(test_dir, commit_id, compare_id)
    finally:
        shutil.rmtree(test_dir)
